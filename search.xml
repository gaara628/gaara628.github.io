<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 101：和你一起你轻松刷题（C++）</title>
      <link href="/2023/08/24/LeetCode101/"/>
      <url>/2023/08/24/LeetCode101/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 101: A LeetCode Grinding Guide (C++ Version)</p><p>《LeetCode 101：和你一起你轻松刷题（C++）》作者：高畅。本博文只是对原书的转载，只为自用，并无任何营利性行为。</p><p>“由于本书的目的是分享和教学，因此本书永久免费，也禁止任何营利性利用。欢迎学术目的的分享和传阅。”——节选自原作·序</p><p>感谢作者的无私奉献</p><h2 id="第-1-章-题目分类"><a href="#第-1-章-题目分类" class="headerlink" title="第 1 章 题目分类"></a>第 1 章 题目分类</h2><p>第一个大分类是算法。本书先从最简单的贪心算法讲起，然后逐渐进阶到二分查找、排序算法和搜索算法，最后是难度比较高的动态规划和分治算法。</p><p>第二个大分类是数学，包括偏向纯数学的数学问题，和偏向计算机知识的位运算问题。这类问题通常用来测试你是否聪敏，在实际工作中并不常用，笔者建议可以优先把精力放在其它大类上。</p><p>第三个大分类是数据结构，包括 C++ STL 内包含的常见数据结构、字符串处理、链表、树和图。其中，链表、树、和图都是用指针表示的数据结构，且前者是后者的子集。最后我们也将介绍一些更加复杂的数据结构，比如经典的并查集和 LRU。</p><h2 id="第-2-章-最易懂的贪心算法"><a href="#第-2-章-最易懂的贪心算法" class="headerlink" title="第 2 章 最易懂的贪心算法"></a>第 2 章 最易懂的贪心算法</h2><h3 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h3><p>顾名思义，贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最后得到的结果是全局最优的。</p><p>举一个最简单的例子：小明和小王喜欢吃苹果，小明可以吃五个，小王可以吃三个。已知苹果园里有吃不完的苹果，求小明和小王一共最多吃多少个苹果。</p><p>在这个例子中，我们可以选用的贪心策略为，每个人吃自己能吃的最多数量的苹果，这在每个人身上都是局部最优的。又因为全局结果是局部结果的简单求和，且局部结果互不相干，因此局部最优的策略也同样是全局最优的策略。</p><h3 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h3><h4 id="455-Assign-Cookies-Easy"><a href="#455-Assign-Cookies-Easy" class="headerlink" title="455. Assign Cookies (Easy)"></a>455. Assign Cookies (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可以吃饱。</p></li><li><p><strong>输入输出样例</strong></p><p>输入两个数组，分别代表孩子的饥饿度和饼干的大小。输出最多有多少孩子可以吃饱的数量。</p><blockquote><p>Input: [1,2], [1,2,3]<br>Output: 2</p></blockquote><p>在这个样例中，我们可以给两个孩子喂[1,2]、[1,3]、[2,3]这三种组合的任意一种。</p></li><li><p><strong>题解</strong></p><p>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。</p><p>简而言之，这里的贪心策略是，给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。</p><p>至于具体实现，因为我们需要获得大小关系，一个便捷的方法就是把孩子和饼干分别排序。这样我们就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少个对子可以满足条件。</p><p><font color=#FF0000 >注意</font> <font face="楷体" >对数组或字符串排序是常见的操作，方便之后的大小比较。</font></p><p><font color=#FF0000 >注意</font> <font face="楷体" >在之后的讲解中，若我们谈论的是对连续空间的变量进行操作，我们并不会明确区分数组和字符串，因为他们本质上都是在连续空间上的有序变量集合。一个字符串“abc”可以被看作一个数组[‘a’,‘b’,‘c’]。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; children, vector&lt;<span class="type">int</span>&gt;&amp; cookies)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(children.<span class="built_in">begin</span>(), children.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(cookies.<span class="built_in">begin</span>(), cookies.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; children.<span class="built_in">size</span>() &amp;&amp; cookie &lt; cookies.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (children[child] &lt;= cookies[cookie])</span><br><span class="line">            ++child;</span><br><span class="line">        ++cookie;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="135-Candy-Hard"><a href="#135-Candy-Hard" class="headerlink" title="135. Candy (Hard)"></a>135. Candy (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果；所有孩子至少要有一个糖果。求解最少需要多少个糖果。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个数组，表示孩子的评分。输出是最少糖果的数量。</p><blockquote><p>Input: [1,0,2]<br>Output: 5</p></blockquote><p>在这个样例中，最少的糖果分法是[2,1,2]。</p></li><li><p><strong>题解</strong></p><p>做完了题目 455，你会不会认为存在比较关系的贪心策略一定需要排序或是选择？虽然这一道题也是运用贪心策略，但我们只需要简单的两次遍历即可：把所有孩子的糖果数初始化为 1；先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。通过这两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系。</p><p>在样例中，我们初始化糖果分配为 [1,1,1]，第一次遍历更新后的结果为 [1,1,2]，第二次遍历更新后的结果为 [2,1,2]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = ratings.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(size, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            num[i] = num[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &lt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            num[i<span class="number">-1</span>] = <span class="built_in">max</span>(num[i<span class="number">-1</span>], num[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// std::accumulate 可以很方便地求和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h3><h4 id="435-Non-overlapping-Intervals-Medium"><a href="#435-Non-overlapping-Intervals-Medium" class="headerlink" title="435. Non-overlapping Intervals (Medium)"></a>435. Non-overlapping Intervals (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个数组，数组由多个长度固定为 2 的数组组成，表示区间的开始和结尾。输出一个整数，表示需要移除的区间数量。</p><blockquote><p>Input: [[1,2], [2,4], [1,3]]<br>Output: 1</p></blockquote><p>在这个样例中，我们可以移除区间[1,3]，使得剩余的区间[[1,2], [2,4]]互不重叠。</p></li><li><p><strong>题解</strong></p><p>在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。</p><p>具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选择的区间不重叠的区间。我们这里使用C++的Lambda，结合std::sort()函数进行自定义排序。</p><p>在样例中，排序后的数组为[[1,2], [1,3], [2,4]]。按照我们的贪心策略，首先初始化为区间[1,2]；由于[1,3]与[1,2]相交，我们跳过该区间；由于[2,4]与[1,2]不相交，我们将其保留。因此最终保留的区间为[[1,2], [2,4]]。</p><p><font color=#FF0000 >注意</font> <font face="楷体" >需要根据实际情况判断按区间开头排序还是按区间结尾排序。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>, prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; prev) &#123;</span><br><span class="line">            ++total;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/can-place-flowers/">605. Can Place Flowers (Easy)</a></p><p><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. Minimum Number of Arrows to Burst Balloons (Medium)</a></p><p><a href="https://leetcode.com/problems/partition-labels/">763. Partition Labels (Medium)</a></p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II (Easy)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/queue-reconstruction-by-height/">406. Queue Reconstruction by Height (Medium)</a></p><p><a href="https://leetcode.com/problems/non-decreasing-array/">665. Non-decreasing Array (Easy)</a></p></li></ul><h2 id="第-3-章-玩转双指针"><a href="#第-3-章-玩转双指针" class="headerlink" title="第 3 章 玩转双指针"></a>第 3 章 玩转双指针</h2><h3 id="算法解释-1"><a href="#算法解释-1" class="headerlink" title="算法解释"></a>算法解释</h3><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。</p><p>若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的区域即为当前的窗口），经常用于区间搜索。</p><p>若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的。</p><p>对于C++语言，指针还可以玩出很多新的花样。一些常见的关于指针的操作如下。</p><ul><li><p><strong>指针与常量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;x; <span class="comment">//指针可以被修改，值也可以被修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;x; <span class="comment">//指针可以被修改，值不可以被修改（const int）</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p3 = &amp;x; <span class="comment">//指针不可以被修改（* const），值可以被修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p4 = &amp;x; <span class="comment">//指针不可以被修改，值也不可以被修改</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指针函数与函数指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addition是指针函数，一个返回类型是指针的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">addition</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *sum = <span class="keyword">new</span> <span class="built_in">int</span>(a + b);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtraction</span><span class="params">(inta, intb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operation</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>(*func)(<span class="type">int</span>, <span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*func)(x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minus是函数指针，指向函数的指针</span></span><br><span class="line"><span class="built_in">int</span>(*minus)(<span class="type">int</span>,<span class="type">int</span>) = subtraction;</span><br><span class="line"><span class="type">int</span>* m = <span class="built_in">addition</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">intn = <span class="built_in">operation</span>(<span class="number">3</span>, *m, minus);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h3><h4 id="167-Two-Sum-II-Input-array-is-sorted-Easy"><a href="#167-Two-Sum-II-Input-array-is-sorted-Easy" class="headerlink" title="167. Two Sum II - Input array is sorted (Easy)"></a>167. Two Sum II - Input array is sorted (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>在一个增序的整数数组里找到两个数，使它们的和为给定值。已知有且只有一对解。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个数组（numbers）和一个给定值（target）。输出是两个数的位置，从 1 开始计数。</p><blockquote><p>Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9<br>Output: [1,2]</p></blockquote><p>在这个样例中，第一个数字（ 2 ）和第二个数字（ 7 ）的和等于给定值（ 9 ）。</p></li><li><p><strong>题解</strong></p><p>因为数组已经排好序，我们可以采用方向相反的双指针来寻找这两个数字，一个初始指向最小的元素，即数组最左边，向右遍历；一个初始指向最大的元素，即数组最右边，向左遍历。</p><p>如果两个指针指向元素的和等于给定值，那么它们就是我们要的结果。如果两个指针指向元素的和小于给定值，我们把左边的指针右移一位，使得当前的和增加一点。如果两个指针指向元素的和大于给定值，我们把右边的指针左移一位，使得当前的和减少一点。</p><p>可以证明，对于排好序且有解的数组，双指针一定能遍历到最优解。证明方法如下：假设最优解的两个数的位置分别是l和r。我们假设在左指针在l左边的时候，右指针已经移动到了r；此时两个指针指向值的和小于给定值，因此左指针会一直右移直到到达l。同理，如果我们假设在右指针在r右边的时候，左指针已经移动到了l；此时两个指针指向值的和大于给定值，因此右指针会一直左移直到到达r。所以双指针在任何时候都不可能处于(l, r)之间，又因为不满足条件时指针必须移动一个，所以最终一定会收敛在l和r。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = numbers.<span class="built_in">size</span>() - <span class="number">1</span>, sum;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        sum = numbers[l] + numbers[r];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) ++l;</span><br><span class="line">        <span class="keyword">else</span> --r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="归并两个有序数组"><a href="#归并两个有序数组" class="headerlink" title="归并两个有序数组"></a>归并两个有序数组</h3><h4 id="88-Merge-Sorted-Array-Easy"><a href="#88-Merge-Sorted-Array-Easy" class="headerlink" title="88. Merge Sorted Array (Easy)"></a>88. Merge Sorted Array (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定两个有序数组，把两个数组合并为一个。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是两个数组和它们分别的长度m和n。其中第一个数组的长度被延长至m+n，多出的n位被 0 填补。题目要求把第二个数组归并到第一个数组上，不需要开辟额外空间。</p><blockquote><p>Input: nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>Output: nums1 &#x3D; [1,2,2,3,5,6]</p></blockquote></li><li><p><strong>题解</strong></p><p>因为这两个数组已经排好序，我们可以把两个指针分别放在两个数组的末尾，即nums1的m 1 位和nums2的n 1 位。每次将较大的那个数字复制到nums1的后边，然后向前移动一位。因为我们也要定位nums1的末尾，所以我们还需要第三个指针，以便复制。<br>在以下的代码里，我们直接利用m和n当作两个数组的指针，再额外创立一个pos指针，起始位置为m + n - 1 。每次向前移动m或n的时候，也要向前移动pos。这里需要注意，如果nums的数字已经复制完，不要忘记把nums2的数字继续复制；如果nums2的数字已经复制完，剩余nums1的数字不需要改变，因为它们已经被排好序。</p><p><font color=#FF0000 >注意</font> <font face="楷体" >这里我们使用了++和–的小技巧：a++和++a都是将a加1，但是a++返回值为a，而++a返回值为a+1。如果只是希望增加a的值，而不需要返回值，则推荐使用++a，其运行速度会略快一些。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = m-- + n-- - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[pos--] = nums1[m] &gt; nums2[n]? nums1[m--]: nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[pos--] = nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><h4 id="142-Linked-List-Cycle-II-Medium"><a href="#142-Linked-List-Cycle-II-Medium" class="headerlink" title="142. Linked List Cycle II (Medium)"></a>142. Linked List Cycle II (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个链表，如果有环路，找出环路的开始点。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个链表，输出是链表的一个节点。如果没有环路，返回一个空指针。</p><p>如果没有特殊说明，LeetCode采用如下的数据结构表示链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>题解</strong></p><p>对于链表找环路的问题，有一个通用的解法——快慢指针（Floyd判圈法）。给定两个指针，分别命名为slow和fast，起始位置在链表的开头。每次fast前进两步，slow前进一步。如果fast可以走到尽头，那么说明没有环路；如果fast可以无限走下去，那么说明一定有环路，且一定存在一个时刻slow和fast相遇。当slow和fast第一次相遇时，我们将fast重新移动到链表开头，并让slow和fast每次都前进一步。当slow和fast第二次相遇时，相遇的节点即为环路的开始点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    <span class="comment">// 判断是否存在环路</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fast || !fast-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line">    <span class="comment">// 如果存在，查找环路节点</span></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="76-Minimum-Window-Substring-Hard"><a href="#76-Minimum-Window-Substring-Hard" class="headerlink" title="76. Minimum Window Substring (Hard)"></a>76. Minimum Window Substring (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定两个字符串S和T，求S中包含T所有字符的最短连续子字符串的长度，同时要求时间复杂度不得超过O(n)。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是两个字符串S和T，输出是一个S字符串的子串。</p><blockquote><p>Input: S &#x3D; “ADOBECODEBANC”, T &#x3D; “ABC”<br>Output: “BANC”</p></blockquote><p>在这个样例中，S中同时包含一个A、一个B、一个C的最短子字符串是“BANC”。</p></li><li><p><strong>题解</strong></p><p>本题使用滑动窗口求解，即两个指针l和r都是从最左端向最右端移动，且l的位置一定在r的左边或重合。注意本题虽然在for循环里出现了一个while循环，但是因为while循环负责移动l指针，且l只会从左到右移动一次，因此总时间复杂度仍然是O(n)。本题使用了长度为 128的数组来映射字符，也可以用哈希表替代；其中chars表示目前每个字符缺少的数量，flag表示每个字符是否在T中存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">chars</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">128</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 先统计T中的字符情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        flag[T[i]] = <span class="literal">true</span>;</span><br><span class="line">        ++chars[T[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动滑动窗口，不断更改统计数据</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, l = <span class="number">0</span>, min_l = <span class="number">0</span>, min_size = S.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; S.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[S[r]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--chars[S[r]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若目前滑动窗口已包含T中全部字符，</span></span><br><span class="line">            <span class="comment">// 则尝试将l右移，在不影响结果的情况下获得最短子字符串</span></span><br><span class="line">            <span class="keyword">while</span> (cnt == T.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; min_size) &#123;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_size = r - l + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag[S[l]] &amp;&amp; ++chars[S[l]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_size &gt; S.<span class="built_in">size</span>()? <span class="string">&quot;&quot;</span>: S.<span class="built_in">substr</span>(min_l, min_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/sum-of-square-numbers/">633. Sum of Square Numbers (Easy)</a></p><p><a href="https://leetcode.com/problems/valid-palindrome-ii/">680. Valid Palindrome II (Easy)</a></p><p><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/">524. Longest Word in Dictionary through Deleting (Medium)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/">340. Longest Substring with At Most K Distinct Characters (Hard)</a></p></li></ul><h2 id="第-4-章-居合斩！二分查找"><a href="#第-4-章-居合斩！二分查找" class="headerlink" title="第 4 章 居合斩！二分查找"></a>第 4 章 居合斩！二分查找</h2><h3 id="算法解释-2"><a href="#算法解释-2" class="headerlink" title="算法解释"></a>算法解释</h3><p>二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。对于一个长度为O¹nº的数组，二分查找的时间复杂度为O(log n)。</p><p>举例来说，给定一个排好序的数组{3,4,5,6,7}，我们希望查找 4 在不在这个数组内。第一次折半时考虑中位数 5 ，因为 5 大于4,所以如果 4 存在于这个数组，那么其必定存在于 5 左边这一半。于是我们的查找区间变成了{3,4,5}。（注意，根据具体情况和您的刷题习惯，这里的 5 可以保留也可以不保留，并不影响时间复杂度的级别。）第二次折半时考虑新的中位数 4 ，正好是我们需要查找的数字。于是我们发现，对于一个长度为 5 的数组，我们只进行了 2 次查找。如果是遍历数组，最坏的情况则需要查找 5 次。</p><p>我们也可以用更加数学的方式定义二分查找。给定一个在 [a, b] 区间内的单调函数 f (x)，若f (a) 和 f (b) 正负性相反，那么必定存在一个解 c，使得 f (c) &#x3D; 0。在上个例子中，f (x) 是离散函数f (x) &#x3D; x +2，查找 4 是否存在等价于求 f (x)−4 &#x3D; 0 是否有离散解。因为 f (1)−4 &#x3D; 3−4 &#x3D; −1 &lt; 0、f (5) − 4 &#x3D; 7 − 4 &#x3D; 3 &gt; 0，且函数在区间内单调递增，因此我们可以利用二分查找求解。如果最后二分到了不能再分的情况，如只剩一个数字，且剩余区间里不存在满足条件的解，则说明不存在离散解，即 4 不在这个数组内。</p><p>具体到代码上，二分查找时区间的左右端取开区间还是闭区间在绝大多数时候都可以，因此有些初学者会容易搞不清楚如何定义区间开闭性。这里我提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足C++、Python等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；第二是在刷题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。</p><p>二分查找也可以看作双指针的一种特殊情况，但我们一般会将二者区分。双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。</p><h3 id="求开方"><a href="#求开方" class="headerlink" title="求开方"></a>求开方</h3><h4 id="69-Sqrt-x-Easy"><a href="#69-Sqrt-x-Easy" class="headerlink" title="69. Sqrt(x) (Easy)"></a>69. Sqrt(x) (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个非负整数，求它的开方，向下取整。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个整数，输出一个整数。</p><blockquote><p>Input: 8<br>Output: 2</p></blockquote><p>8 的开方结果是 2.82842…，向下取整即是 2</p></li><li><p><strong>题解</strong></p><p>我们可以把这道题想象成，给定一个非负整数 a，求 f (x) &#x3D; x2 − a &#x3D; 0 的解。因为我们只考虑 x ≥ 0，所以 f (x) 在定义域上是单调递增的。考虑到 f (0) &#x3D; −a ≤ 0， f (a) &#x3D; a2 − a ≥ 0，我们可以对 [0,a] 区间使用二分法找到 f (x) &#x3D; 0 的解。</p><p>注意，在以下的代码里，为了防止除以 0，我们把 a &#x3D; 0 的情况单独考虑，然后对区间 [1,a]进行二分查找。我们使用了左闭右闭的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = a, mid, sqrt;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        sqrt = a / mid;</span><br><span class="line">        <span class="keyword">if</span> (sqrt == mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; sqrt) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，这道题还有一种更快的算法——牛顿迭代法，其公式为 xn+1 &#x3D; xn − f (xn)&#x2F; f ′(xn)。给定 f (x) &#x3D; x2 − a &#x3D; 0，这里的迭代公式为 xn+1 &#x3D; (xn + a&#x2F;xn)&#x2F;2，其代码如下。</p><p><font color=#FF0000 >注意</font> <font face="楷体" >这里为了防止 int 超上界，我们使用 long 来存储乘法结果。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> x = a;</span><br><span class="line">    <span class="keyword">while</span> (x * x &gt; a) &#123;</span><br><span class="line">        x = (x + a / x) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查找区间"><a href="#查找区间" class="headerlink" title="查找区间"></a>查找区间</h3><h4 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array (Medium)"></a>34. Find First and Last Position of Element in Sorted Array (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个增序的整数数组和一个值，查找该值第一次和最后一次出现的位置。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个数组和一个值，输出为该值第一次出现的位置和最后一次出现的位置（从 0 开始）；如果不存在该值，则两个返回值都设为-1。</p><blockquote><p>Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>Output: [3,4]</p></blockquote><p>数字 8 在第 3 位第一次出现，在第 4 位最后一次出现。</p></li><li><p><strong>题解</strong></p><p>这道题可以看作是自己实现 C++ 里的 lower_bound 和 upper_bound 函数。这里我们尝试使用左闭右开的写法，当然左闭右闭也可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> lower = <span class="built_in">lower_bound</span>(nums, target);</span><br><span class="line">    <span class="type">int</span> upper = <span class="built_in">upper_bound</span>(nums, target) - <span class="number">1</span>; <span class="comment">// 这里需要减1位</span></span><br><span class="line">    <span class="keyword">if</span> (lower == nums.<span class="built_in">size</span>() || nums[lower] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;lower, upper&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="旋转数组查找数字"><a href="#旋转数组查找数字" class="headerlink" title="旋转数组查找数字"></a>旋转数组查找数字</h3><h4 id="81-Search-in-Rotated-Sorted-Array-II-Medium"><a href="#81-Search-in-Rotated-Sorted-Array-II-Medium" class="headerlink" title="81. Search in Rotated Sorted Array II (Medium)"></a>81. Search in Rotated Sorted Array II (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>一个原本增序的数组被首尾相连后按某个位置断开（如[1,2,2,3,4,5]![2,3,4,5,1,2]，在第一位和第二位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个为旋转数组中。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个数组和一个值，输出是一个布尔值，表示数组中是否存在该值。</p><blockquote><p>Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0<br>Output: true</p></blockquote></li><li><p><strong>题解</strong></p><p>即使数组被旋转过，我们仍然可以利用这个数组的递增性，使用二分查找。对于当前的中点，如果它指向的值小于等于右端，那么说明右区间是排好序的；反之，那么说明左区间是排好序的。如果目标值位于排好序的区间内，我们可以对这个区间继续二分查找；反之，我们对于另一半区间继续二分查找。</p><p>注意，因为数组存在重复数字，如果中点和左端的数字相同，我们并不能确定是左区间全部相同，还是右区间完全相同。在这种情况下，我们可以简单地将左端点右移一位，然后继续进行二分查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[start] == nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 无法判断哪个区间是增序的</span></span><br><span class="line">            ++start;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= nums[end]) &#123;</span><br><span class="line">            <span class="comment">// 右区间是增序的</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左区间是增序的</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. Find Minimum in Rotated Sorted Array II (Medium)</a></p><p><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/">540. Single Element in a Sorted Array (Medium)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">4. Median of Two Sorted Arrays (Hard)</a></p></li></ul><h2 id="第-5-章-千奇百怪的排序算法"><a href="#第-5-章-千奇百怪的排序算法" class="headerlink" title="第 5 章 千奇百怪的排序算法"></a>第 5 章 千奇百怪的排序算法</h2><h3 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h3><p>以下是一些最基本的排序算法。虽然在C++里可以通过std::sort()快速排序，而且刷题时很少需要自己手写排序算法，但是熟习各种排序算法可以加深自己对算法的基本理解，以及解出由这些排序算法引申出来的题目。</p><ul><li><p><strong>快速排序（Quicksort）</strong></p><p>我们采用左闭右闭的二分写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> first = l, last = r - <span class="number">1</span>, key = nums[first];</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last)&#123;</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; nums[last] &gt;= key) &#123;</span><br><span class="line">            --last;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[first] = nums[last];</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; nums[first] &lt;= key) &#123;</span><br><span class="line">            ++first;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[last] = nums[first];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[first] = key;</span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, l, first);</span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, first + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>归并排序（Merge Sort）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// divide</span></span><br><span class="line">    <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, l, m, temp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, m, r, temp);</span><br><span class="line">    <span class="comment">// conquer</span></span><br><span class="line">    <span class="type">int</span> p = l, q = m, i = l;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; m || q &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) &#123;</span><br><span class="line">            temp[i++] = nums[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[i++] = nums[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入排序（Insertion Sort）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j<span class="number">-1</span>]; --j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[j], nums[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>冒泡排序（Bubble Sort）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - i + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j<span class="number">-1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>选择排序（Selection Sort）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        mid = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[mid]) &#123;</span><br><span class="line">                mid = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[mid], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><h4 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a>215. Kth Largest Element in an Array</h4><ul><li><p><strong>题目描述</strong></p><p>在一个未排序的数组中，找到第k大的数字。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个数组和一个目标值k，输出第k大的数字。题目默认一定有解。</p><blockquote><p>Input: [3,2,1,5,6,4] and k &#x3D; 2<br>Output: 5</p></blockquote></li><li><p><strong>题解</strong></p><p>快速选择一般用于求解 k-th Element 问题，可以在 O(n) 时间复杂度，O(1) 空间复杂度完成求解工作。快速选择的实现和快速排序相似，不过只需要找到第 k 大的枢（pivot）即可，不需要对其左右再进行排序。与快速排序一样，快速选择一般需要先打乱数组，否则最坏情况下时间复杂度为 O(n2)，我们这里为了方便省略掉了打乱的步骤。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">quickSelection</span>(nums, l, r);</span><br><span class="line">        <span class="keyword">if</span> (mid == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; target) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数 - 快速选择</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSelection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; r &amp;&amp; nums[i] &lt;= nums[l]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; j &amp;&amp; nums[j] &gt;= nums[l]) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h4 id="347-Top-K-Frequent-Elements-Medium"><a href="#347-Top-K-Frequent-Elements-Medium" class="headerlink" title="347. Top K Frequent Elements (Medium)"></a>347. Top K Frequent Elements (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个数组，求前k个最频繁的数字。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个数组和一个目标值k。输出是一个长度为k的数组。</p><blockquote><p>Input: nums &#x3D; [1,1,1,1,2,2,3,4], k &#x3D; 2<br>Output: [1,2]</p></blockquote><p>在这个样例中，最频繁的两个数是 1 和 2 。</p></li><li><p><strong>题解</strong></p><p>顾名思义，桶排序的意思是为每个值设立一个桶，桶内记录这个值出现的次数（或其它属性），然后对桶进行排序。针对样例来说，我们先通过桶排序得到三个桶 [1,2,3,4]，它们的值分别为 [4,2,1,1]，表示每个数字出现的次数。</p><p>紧接着，我们对桶的频次进行排序，前 k 大个桶即是前 k 个频繁的数。这里我们可以使用各种排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。针对样例来说，因为目前最大的频次是 4，我们建立 [1,2,3,4] 四个新桶，它们分别放入的旧桶为 [[3,4],[2],[],[1]]，表示不同数字出现的频率。最后，我们从后往前遍历，直到找到 k 个旧桶。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num : nums) &#123;</span><br><span class="line">        max_count = <span class="built_in">max</span>(max_count, ++counts[num]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(max_count + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; p : counts) &#123;</span><br><span class="line">        buckets[p.second].<span class="built_in">push_back</span>(p.first);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = max_count; i &gt;= <span class="number">0</span> &amp;&amp; ans.<span class="built_in">size</span>() &lt; k; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num : buckets[i]) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/sort-characters-by-frequency/">451. Sort Characters By Frequency (Medium)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/sort-colors/">75. Sort Colors (Medium)</a></p></li></ul><h2 id="第-6-章-一切皆可搜索"><a href="#第-6-章-一切皆可搜索" class="headerlink" title="第 6 章 一切皆可搜索"></a>第 6 章 一切皆可搜索</h2><h3 id="算法解释-3"><a href="#算法解释-3" class="headerlink" title="算法解释"></a>算法解释</h3><p>深度优先搜索和广度优先搜索是两种最常见的优先搜索方法，它们被广泛地运用在图和树等结构中进行搜索。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。</p><p>考虑如下一颗简单的树。我们从 1 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，那么按照优先向着“深”的方向前进的策略，假如我们使用递归实现，我们的遍历过程为 1 （起始节点）-&gt;2（遍历更深一层的左子节点）-&gt;4（遍历更深一层的左子节点）-&gt;2（无子节点，返回父结点）-&gt;1（子节点均已完成遍历，返回父结点）-&gt;3（遍历更深一层的右子节点）-&gt;1（无子节点，返回父结点）-&gt;结束程序（子节点均已完成遍历）。如果我们使用栈实现，我们的栈顶元素的变化过程为1-&gt;2-&gt;4-&gt;3。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TB1((1))2((2))3((3))4((4))1---21---32---0(( ))style 0 fill:#f100,stroke-width:0px2---4linkStyle 2 stroke:#0ff,stroke-width:0px  </pre></div><p>深度优先搜索也可以用来检测环路：记录每个遍历过的节点的父节点，若一个节点被再次遍历且父节点不同，则说明有环。我们也可以用之后会讲到的拓扑排序判断是否有环路，若最后存在入度不为零的点，则说明有环。</p><p>有时我们可能会需要对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点，这种做法叫做状态记录或记忆化（memoization）。</p><h4 id="695-Max-Area-of-Island-Easy"><a href="#695-Max-Area-of-Island-Easy" class="headerlink" title="695. Max Area of Island (Easy)"></a>695. Max Area of Island (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个二维的0-1矩阵，其中 0 表示海洋， 1 表示陆地。单独的或相邻的陆地可以形成岛屿，每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维数组，输出是一个整数，表示最大的岛屿面积。</p><blockquote><p>Input:<br>[[1,0,1,1,0,1,0,1],<br>[1,0,1,1,0,1,1,1],<br>[0,0,0,0,0,0,0,1]]<br>Output: 6</p></blockquote><p>最大的岛屿面积为 6 ，位于最右侧。</p></li><li><p><strong>题解</strong></p><p>此题是十分标准的搜索题，我们可以拿来练手深度优先搜索。一般来说，深度优先搜索类型的题可以分为主函数和辅函数，主函数用于遍历所有的搜索位置，判断是否可以开始搜索，如果可以即在辅函数进行搜索。辅函数则负责深度优先搜索的递归调用。当然，我们也可以使用栈（stack）实现深度优先搜索，但因为栈与递归的调用原理相同，而递归相对便于实现，因此刷题时笔者推荐使用递归式写法，同时也方便进行回溯（见下节）。不过在实际工程上，直接使用栈可能才是最好的选择，一是因为便于理解，二是更不易出现递归栈满的情况。我们先展示使用栈的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = m ? grid[<span class="number">0</span>].<span class="built_in">size</span>(): <span class="number">0</span>, local_area, area = <span class="number">0</span>, x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]) &#123;</span><br><span class="line">                local_area = <span class="number">1</span>;</span><br><span class="line">                grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; island;</span><br><span class="line">                island.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                <span class="keyword">while</span> (!island.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> [r, c] = island.<span class="built_in">top</span>();</span><br><span class="line">                    island.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        x = r + direction[k], y = c + direction[k+<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp;</span><br><span class="line">                            y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                            grid[x][y] = <span class="number">0</span>;</span><br><span class="line">                            ++local_area;</span><br><span class="line">                            island.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                area = <span class="built_in">max</span>(area, local_area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了一个小技巧，对于四个方向的遍历，可以创造一个数组 [-1, 0, 1, 0, -1]，每相邻两位即为上下左右四个方向之一。</p><p>在辅函数里，一个一定要注意的点是辅函数内递归搜索时，边界条件的判定。边界判定一般有两种写法，一种是先判定是否越界，只有在合法的情况下才进行下一步搜索（即判断放在调用递归函数前）；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合法（即判断放在辅函数第一行）。我们这里分别展示这两种写法。</p><p>第一种递归写法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x, y, area = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        x = r + direction[i], y = c + direction[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            area += <span class="built_in">dfs</span>(grid, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种递归写法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= grid.<span class="built_in">size</span>() ||</span><br><span class="line">        c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c) + <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c) +</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>) + <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="547-Friend-Circles-Medium"><a href="#547-Friend-Circles-Medium" class="headerlink" title="547. Friend Circles (Medium)"></a>547. Friend Circles (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个二维的0-1矩阵，如果第(i, j)位置是 1 ，则表示第i个人和第j个人是朋友。已知朋友关系是可以传递的，即如果a是b的朋友，b是c的朋友，那么a和c也是朋友，换言之这三个人处于同一个朋友圈之内。求一共有多少个朋友圈。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维数组，输出是一个整数，表示朋友圈数量。因为朋友关系具有对称性，该二维数组为对称矩阵。同时，因为自己是自己的朋友，对角线上的值全部为 1 。</p><blockquote><p>Input:<br>[[1,1,0],<br>[1,1,0],<br>[0,0,1]]<br>Output: 2</p></blockquote><p>在这个样例中，[1,2]处于一个朋友圈，[3]处于一个朋友圈。</p></li><li><p><strong>题解</strong></p><p>对于题目 695 ，图的表示方法是，每个位置代表一个节点，每个节点与上下左右四个节点相邻。而在这一道题里面，每一行（列）表示一个节点，它的每列（行）表示是否存在一个相邻节点。因此题目 695 拥有m * n个节点，每个节点有 4 条边；而本题拥有n个节点，每个节点最多有n条边，表示和所有人都是朋友，最少可以有 1 条边，表示自己与自己相连。当清楚了图的表示方法后，这道题与题目 695 本质上是同一道题：搜索朋友圈（岛屿）的个数（最大面积）。我们这里采用递归的第一种写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; friends)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = friends.<span class="built_in">size</span>(), count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(friends, i, visited);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; friends, <span class="type">int</span> i, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; friends.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (friends[i][k] == <span class="number">1</span> &amp;&amp; !visited[k]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(friends, k, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="417-Pacific-Atlantic-Water-Flow-Medium"><a href="#417-Pacific-Atlantic-Water-Flow-Medium" class="headerlink" title="417. Pacific Atlantic Water Flow (Medium)"></a>417. Pacific Atlantic Water Flow (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个二维的非负整数矩阵，每个位置的值表示海拔高度。假设左边和上边是太平洋，右边和下边是大西洋，求从哪些位置向下流水，可以流到太平洋和大西洋。水只能从海拔高的位置流到海拔低或相同的位置。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维的非负整数数组，表示海拔高度。输出是一个二维的数组，其中第二个维度大小固定为 2 ，表示满足条件的位置坐标。</p><blockquote><p>Input:<br>P ~ ~ ~ ~ ~ ~ ~ ~ ~ * *<br>~ ~ ~ ~  1 2 2 3 <strong>5</strong> * * * *<br>~ ~ ~ ~  3 2 3 <strong>4</strong> <strong>4</strong> * * * *<br>~ ~ ~ ~  2 4 <strong>5</strong> 3 1 * * * *<br>~ ~ ~ ~  <strong>6</strong> <strong>7</strong> 1 4 5 * * * *<br>~ ~ ~ ~  <strong>5</strong> 1 1 2 4 * * * *</p><p>~ ~ * * * * * * * * * * * A</p><p>Output: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]</p></blockquote><p>在这个样例中，深色的区域为满足条件的位置。</p></li><li><p><strong>题解</strong></p><p>虽然题目要求的是满足向下流能到达两个大洋的位置，如果我们对所有的位置进行搜索，那么在不剪枝的情况下复杂度会很高。因此我们可以反过来想，从两个大洋开始向上流，这样我们只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋向上流都能到达的位置。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">can_reach_p</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">can_reach_a</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, i, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, <span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, m - <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_reach_p[i][j] &amp;&amp; can_reach_a[i][j]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; can_reach, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (can_reach[r][c]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    can_reach[r][c] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        x = r + direction[i], y = c + direction[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.<span class="built_in">size</span>()</span><br><span class="line">            &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">            matrix[r][c] &lt;= matrix[x][y]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(matrix, can_reach, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>回溯法（backtracking）是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状态的深度优先搜索。通常来说，排列、组合、选择类问题使用回溯法比较方便。</p><p>顾名思义，回溯法的核心是回溯。在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态还原。这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。在具体的写法上，它与普通的深度优先搜索一样，都有[修改当前节点状态]→[递归子节点] 的步骤，只是多了回溯的步骤，变成了[修改当前节点状态]→[递归子节点]→[回改当前节点<br>状态]。</p><p>没有接触过回溯法的读者可能会不明白我在讲什么，这也完全正常，希望以下几道题可以让您理解回溯法。如果还是不明白，可以记住两个小诀窍，一是按引用传状态，二是所有的状态修改在递归完成后回改。</p><p>回溯法修改一般有两种情况，一种是修改最后一位输出，比如排列组合；一种是修改访问标记，比如矩阵里搜字符串。</p><h4 id="46-Permutations-Medium"><a href="#46-Permutations-Medium" class="headerlink" title="46. Permutations (Medium)"></a>46. Permutations (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个无重复数字的整数数组，求其所有的排列方式。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个一维整数数组，输出是一个二维数组，表示输入数组的所有排列方式。</p><blockquote><p>Input: [1,2,3]<br>Output: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</p></blockquote><p>可以以任意顺序输出，只要包含了所有排列方式即可。</p></li><li><p><strong>题解</strong></p><p>怎样输出所有的排列方式呢？对于每一个当前位置i，我们可以将其于之后的任意位置交换，然后继续处理位置i+1，直到处理到最后一位。为了防止我们每此遍历时都要新建一个子数组储存位置i之前已经交换好的数字，我们可以利用回溯法，只对原数组进行修改，在递归完成后再修改回来。</p><p>我们以样例[1,2,3]为例，按照这种方法，我们输出的数组顺序为[[1,2,3], [1,3,2], [2,1,3], [2,3,1],[3,1,2], [3,2,1]]，可以看到所有的排列在这个算法中都被考虑到了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> level, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = level; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, level+<span class="number">1</span>, ans); <span class="comment">// 递归子节点</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="77-Combinations-Medium"><a href="#77-Combinations-Medium" class="headerlink" title="77. Combinations (Medium)"></a>77. Combinations (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个整数n和一个整数k，求在 1 到n中选取k个数字的所有组合方法。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是两个正整数n和k，输出是一个二维数组，表示所有组合方式。</p><blockquote><p>Input: n &#x3D; 4, k &#x3D; 2<br>Output: [[2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]</p></blockquote><p>这里二维数组的每个维度都可以以任意顺序输出。</p></li><li><p><strong>题解</strong></p><p>类似于排列问题，我们也可以进行回溯。排列回溯的是交换的位置，而组合回溯的是否把当前的数字加入结果中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">comb</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(ans, comb, count, <span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; comb, <span class="type">int</span>&amp; count, <span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt;= n; ++i) &#123;</span><br><span class="line">        comb[count++] = i; <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(ans, comb, count, i + <span class="number">1</span>, n, k); <span class="comment">// 递归子节点</span></span><br><span class="line">        --count; <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="79-Word-Search-Medium"><a href="#79-Word-Search-Medium" class="headerlink" title="79. Word Search (Medium)"></a>79. Word Search (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个字母矩阵，所有的字母都与上下左右四个方向上的字母相连。给定一个字符串，求字符串能不能在字母矩阵中寻找到。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维字符数组和一个字符串，输出是一个布尔值，表示字符串是否可以被寻找到。</p><blockquote><p>Input: word &#x3D; “ABCCED”, board &#x3D;</p><p>[[’A’,’B’,’C’,’E’],</p><p>[’S’,’F’,’C’,’S’],</p><p>[’A’,’D’,’E’,’E’]]</p><p>Output: true</p></blockquote><p>从左上角的’A’开始，我们可以先向右、再向下、最后向左，找到连续的”ABCCED”。</p></li><li><p><strong>题解</strong></p><p>不同于排列组合问题，本题采用的并不是修改输出方式，而是修改访问标记。在我们对任意位置进行深度优先搜索时，我们先标记当前位置为已访问，以避免重复遍历（如防止向右搜索后又向左返回）；在所有的可能都搜索完成后，再回改当前位置为未访问，防止干扰其它位置搜索到当前位置。使用回溯法，我们可以只对一个二维的访问矩阵进行修改，而不用把每次的搜索状态作为一个新对象传入递归函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="type">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">backtracking</span>(i, j, board, word, find, visited, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="type">bool</span>&amp; find, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j] || find || board[i][j] != word[pos]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        find = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="literal">true</span>; <span class="comment">// 修改当前节点状态</span></span><br><span class="line">    <span class="comment">// 递归子节点</span></span><br><span class="line">    <span class="built_in">backtracking</span>(i + <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i - <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j + <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j - <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    visited[i][j] = <span class="literal">false</span>; <span class="comment">// 回改当前节点状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="51-N-Queens-Hard"><a href="#51-N-Queens-Hard" class="headerlink" title="51. N-Queens (Hard)"></a>51. N-Queens (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个大小为n的正方形国际象棋棋盘，求有多少种方式可以放置n个皇后并使得她们互不攻击，即每一行、列、左斜、右斜最多只有一个皇后。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个整数n，输出是一个二维字符串数组，表示所有的棋盘表示方法。</p><blockquote><p>Input: 4<br>Output: [<br>[“.Q..”, &#x2F;&#x2F; Solution 1<br>“…Q”,<br>“Q…”,<br>“..Q.”],<br>[“..Q.”, &#x2F;&#x2F; Solution 2<br>“Q…”,<br>“…Q”,<br>“.Q..”]<br>]</p></blockquote><p>在这个样例中，点代表空白位置，Q代表皇后。</p></li><li><p><strong>题解</strong></p><p>类似于在矩阵中寻找字符串，本题也是通过修改状态矩阵来进行回溯。不同的是，我们需要对每一行、列、左斜、右斜建立访问数组，来记录它们是否存在皇后。</p><p>本题有一个隐藏的条件，即满足条件的结果中每一行或列有且仅有一个皇后。这是因为我们一共只有n行和n列。所以如果我们通过对每一行遍历来插入皇后，我们就不需要对行建立访问数组了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, ’.’))</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">column</span><span class="params">(n, <span class="literal">false</span>)</span>, <span class="title">ldiag</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>, <span class="literal">false</span>)</span>, <span class="title">rdiag</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(ans, board, column, ldiag, rdiag, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;string&gt;&gt; &amp;ans, vector&lt;string&gt; &amp;board, vector&lt;<span class="type">bool</span>&gt; &amp;column, vector&lt;<span class="type">bool</span>&gt; &amp;ldiag, vector&lt;<span class="type">bool</span>&gt; &amp;rdiag, <span class="type">int</span> row, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (column[i] || ldiag[n-row+i<span class="number">-1</span>] || rdiag[row+i+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        board[row][i] = ’Q’;</span><br><span class="line">        column[i] = ldiag[n-row+i<span class="number">-1</span>] = rdiag[row+i+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 递归子节点</span></span><br><span class="line">        <span class="built_in">backtracking</span>(ans, board, column, ldiag, rdiag, row+<span class="number">1</span>, n);</span><br><span class="line">        <span class="comment">// 回改当前节点状态</span></span><br><span class="line">        board[row][i] = ’.’;</span><br><span class="line">        column[i] = ldiag[n-row+i<span class="number">-1</span>] = rdiag[row+i+<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索（breadth-first search，BFS）不同与深度优先搜索，它是一层层进行遍历的，因此需要用先入先出的队列而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时按照“广”的方向进行遍历的，也常常用来处理最短路径等问题。</p><p>考虑如下一颗简单的树。我们从 1 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，那么按照优先向着“广”的方向前进的策略，队列顶端的元素变化过程为[1]-&gt;[2-&gt;3]-&gt;[4]，其中方括号代表每一层的元素。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TB1((1))2((2))3((3))4((4))1---21---32---42---0(( ))style 0 fill:#f100,stroke-width:0pxlinkStyle 3 stroke:#0ff,stroke-width:0px  </pre></div><p>这里要注意，深度优先搜索和广度优先搜索都可以处理可达性问题，即从一个节点开始是否能达到另一个节点。因为深度优先搜索可以利用递归快速实现，很多人会习惯使用深度优先搜索刷此类题目。实际软件工程中，笔者很少见到递归的写法，因为一方面难以理解，另一方面可能产生栈溢出的情况；而用栈实现的深度优先搜索和用队列实现的广度优先搜索在写法上并没有太大差异，因此使用哪一种搜索方式需要根据实际的功能需求来判断。</p><h4 id="934-Shortest-Bridge-Medium"><a href="#934-Shortest-Bridge-Medium" class="headerlink" title="934. Shortest Bridge (Medium)"></a>934. Shortest Bridge (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个二维0-1矩阵，其中 1 表示陆地， 0 表示海洋，每个位置与上下左右相连。已知矩阵中有且只有两个岛屿，求最少要填海造陆多少个位置才可以将两个岛屿相连。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维整数数组，输出是一个非负整数，表示需要填海造陆的位置数。</p><blockquote><p>Input:<br>[[1,1,1,1,1],<br>[1,0,0,0,1],<br>[1,0,1,0,1],<br>[1,0,0,0,1],<br>[1,1,1,1,1]]<br>Output: 1</p></blockquote></li><li><p><strong>题解</strong> </p><p>本题实际上是求两个岛屿间的最短距离，因此我们可以先通过任意搜索方法找到其中一个岛屿，然后利用广度优先搜索，查找其与另一个岛屿的最短距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; points;</span><br><span class="line">    <span class="comment">// dfs寻找第一个岛屿，并把1全部赋值为2</span></span><br><span class="line">    <span class="type">bool</span> flipped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flipped) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(points, grid, m, n, i, j);</span><br><span class="line">                flipped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs寻找第二个岛屿，并把过程中经过的0赋值为2</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!points.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        ++level;</span><br><span class="line">        <span class="type">int</span> n_points = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (n_points--) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = points.<span class="built_in">front</span>();</span><br><span class="line">            points.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                x = r + direction[k], y = c + direction[k+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    &#125;</span><br><span class="line">                    points.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; points, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == m || j == n || grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        points.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="126-Word-Ladder-II-Hard"><a href="#126-Word-Ladder-II-Hard" class="headerlink" title="126. Word Ladder II (Hard)"></a>126. Word Ladder II (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个起始字符串和一个终止字符串，以及一个单词表，求是否可以将起始字符串每次改一个字符，直到改成终止字符串，且所有中间的修改过程表示的字符串都可以在单词表里找到。若存在，输出需要修改次数最少的所有更改方式。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是两个字符串，输出是一个二维字符串数组，表示每种字符串修改方式。</p><blockquote><p>Input: beginWord &#x3D; “hit”, endWord &#x3D; “cog”,<br>wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>Output:<br>[[“hit”,”hot”,”dot”,”dog”,”cog”],<br>[“hit”,”hot”,”lot”,”log”,”cog”]]</p></blockquote></li><li><p><strong>题解</strong></p><p>我们可以把起始字符串、终止字符串、以及单词表里所有的字符串想象成节点。若两个字符串只有一个字符不同，那么它们相连。因为题目需要输出修改次数最少的所有修改方式，因此我们可以使用广度优先搜索，求得起始节点到终止节点的最短距离。</p><p>我们同时还使用了一个小技巧：我们并不是直接从起始节点进行广度优先搜索，直到找到终止节点为止；而是从起始节点和终止节点分别进行广度优先搜索，每次只延展当前层节点数最少的那一端，这样我们可以减少搜索的总结点数。举例来说，假设最短距离为 4 ，如果我们只从一端搜索 4 层，总遍历节点数最多是 1 + 2 + 4 + 8 + 16 &#x3D; 31 ；而如果我们从两端各搜索两层，总遍历节点数最多只有 2 × (1 + 2 + 4) &#x3D; 14。</p><p> 在搜索结束后，我们还需要通过回溯法来重建所有可能的路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    unordered_set&lt;string&gt; dict;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;w: wordList)&#123;</span><br><span class="line">        dict.<span class="built_in">insert</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!dict.<span class="built_in">count</span>(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    dict.<span class="built_in">erase</span>(beginWord);</span><br><span class="line">    dict.<span class="built_in">erase</span>(endWord);</span><br><span class="line">    unordered_set&lt;string&gt; q1&#123;beginWord&#125;, q2&#123;endWord&#125;;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; next;</span><br><span class="line">    <span class="type">bool</span> reversed = <span class="literal">false</span>, found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        unordered_set&lt;string&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;w: q1) &#123;</span><br><span class="line">            string s = w;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="type">char</span> ch = s[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                    s[i] = j + ’a’;</span><br><span class="line">                    <span class="keyword">if</span> (q2.<span class="built_in">count</span>(s)) &#123;</span><br><span class="line">                        reversed ? next[s].<span class="built_in">push_back</span>(w): next[w].<span class="built_in">push_back</span>(s);</span><br><span class="line">                        found = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (dict.<span class="built_in">count</span>(s)) &#123;</span><br><span class="line">                        reversed ? next[s].<span class="built_in">push_back</span>(w): next[w].<span class="built_in">push_back</span>(s);</span><br><span class="line">                        q.<span class="built_in">insert</span>(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                s[i] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;w: q) &#123;</span><br><span class="line">            dict.<span class="built_in">erase</span>(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt;= q2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            q1 = q;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reversed = !reversed;</span><br><span class="line">            q1 = q2;</span><br><span class="line">            q2 = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        vector&lt;string&gt; path = &#123;beginWord&#125;;</span><br><span class="line">        <span class="built_in">backtracking</span>(beginWord, endWord, next, path, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string &amp;src, <span class="type">const</span> string &amp;dst, unordered_map&lt;string, vector&lt;string&gt;&gt; &amp;next, vector&lt;string&gt; &amp;path, vector&lt;vector&lt;string&gt;&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == dst) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;s: next[src]) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="built_in">backtracking</span>(s, dst, next, path, ans);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/surrounded-regions/">130. Surrounded Regions (Medium)</a></p><p><a href="https://leetcode.com/problems/binary-tree-paths/">257. Binary Tree Paths (Easy)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/permutations-ii/">47. Permutations II (Medium)</a></p><p><a href="https://leetcode.com/problems/combination-sum-ii/">40. Combination Sum II (Medium)</a></p><p><a href="https://leetcode.com/problems/sudoku-solver/">37. Sudoku Solver (Hard)</a></p><p><a href="https://leetcode.com/problems/minimum-height-trees/">310. Minimum Height Trees (Medium)</a></p></li></ul><h2 id="第-7-章-深入浅出动态规划"><a href="#第-7-章-深入浅出动态规划" class="headerlink" title="第 7 章 深入浅出动态规划"></a>第 7 章 深入浅出动态规划</h2><h3 id="算法解释-4"><a href="#算法解释-4" class="headerlink" title="算法解释"></a>算法解释</h3><p>这里我们引用一下维基百科的描述：“动态规划（Dynamic Programming, DP）在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间 动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。”</p><p>通俗一点来讲，动态规划和其它遍历算法（如深&#x2F;广度优先搜索）都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存子问题的解，避免重复计算。解决动态规划问题的关键是找到状态转移方程，这样我们可以通过计算和储存子问题的解来求解最终问题。</p><p>同时，我们也可以对动态规划进行空间压缩，起到节省空间消耗的效果。这一技巧笔者将在之后的题目中介绍。</p><p>在一些情况下，动态规划可以看成是带有状态记录（memoization）的优先搜索。状态记录的意思为，如果一个子问题在优先搜索时已经计算过一次，我们可以把它的结果储存下来，之后遍历到该子问题的时候可以直接返回储存的结果。动态规划是自下而上的，即先解决子问题，再解决父问题；而用带有状态记录的优先搜索是自上而下的，即从父问题搜索到子问题，若重复搜索到同一个子问题则进行状态记录，防止重复计算。如果题目需求的是最终状态，那么使用动态搜索比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便。</p><h3 id="基本动态规划：一维"><a href="#基本动态规划：一维" class="headerlink" title="基本动态规划：一维"></a>基本动态规划：一维</h3><h4 id="70-Climbing-Stairs-Easy"><a href="#70-Climbing-Stairs-Easy" class="headerlink" title="70. Climbing Stairs (Easy)"></a>70. Climbing Stairs (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定n节台阶，每次可以走一步或走两步，求一共有多少种方式可以走完这些台阶。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个数字，表示台阶数量；输出是爬台阶的总方式。</p><blockquote><p>Input: 3<br>Output: 3</p></blockquote><p>在这个样例中，一共有三种方法走完这三节台阶：每次走一步；先走一步，再走两步；先走两步，再走一步。</p></li><li><p><strong>题解</strong></p><p>这是十分经典的斐波那契数列题。定义一个数组dp，dp[i]表示走到第i阶的方法数。因为我们每次可以走一步或者两步，所以第i阶可以从第i-1或i-2阶到达。换句话说，走到第i阶的方法数即为走到第i-1阶的方法数加上走到第i-2阶的方法数。这样我们就得到了状态转移方程dp[i] &#x3D; dp[i-1] + dp[i-2]。注意边界条件的处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步的，我们可以对动态规划进行空间压缩。因为 dp[i] 只与 dp[i-1] 和 dp[i-2] 有关，因此可以只用两个变量来存储 dp[i-1] 和 dp[i-2]，使得原来的 O(n) 空间复杂度优化为 O(1) 复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>, cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cur = pre1 + pre2;</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="198-House-Robber-Easy"><a href="#198-House-Robber-Easy" class="headerlink" title="198. House Robber (Easy)"></a>198. House Robber (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。</p><blockquote><p>Input: [2,7,9,3,1]<br>Output: 12</p></blockquote><p>在这个样例中，最多的抢劫方式为抢劫第 1 、3 、 5 个房子。</p></li><li><p><strong>题解</strong></p><p>定义一个数组dp，dp[i]表示抢劫到第i个房子时，可以抢劫的最大数量。我们考虑dp[i]，此时可以抢劫的最大数量有两种可能，一种是我们选择不抢劫这个房子，此时累计的金额即为dp[i-1]；另一种是我们选择抢劫这个房子，那么此前累计的最大金额只能是dp[i-2]，因为我们不能够抢劫第i-1个房子，否则会触发警报机关。因此本题的状态转移方程为dp[i] &#x3D; max(dp[i-1],nums[i-1] + dp[i-2])。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>], nums[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们可以像题目 70 那样，对空间进行压缩。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>, cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cur = <span class="built_in">max</span>(pre2 + nums[i], pre1);</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="413-Arithmetic-Slices-Medium"><a href="#413-Arithmetic-Slices-Medium" class="headerlink" title="413. Arithmetic Slices (Medium)"></a>413. Arithmetic Slices (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个数组，求这个数组中连续且等差的子数组一共有多少个。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个一维数组，输出是满足等差条件的连续字数组个数。</p><blockquote><p>Input: nums &#x3D; [1,2,3,4]<br>Output: 3</p></blockquote><p>在这个样例中，等差数列有[1,2,3]、[2,3,4]和[1,2,3,4]。</p></li><li><p><strong>题解</strong></p><p>这道题略微特殊，因为要求是等差数列，可以很自然的想到子数组必定满足num[i] - num[i-1]&#x3D; num[i-1] - num[i-2]。然而由于我们对于dp数组的定义通常为以i结尾的，满足某些条件的子数组数量，而等差子数组可以在任意一个位置终结，因此此题在最后需要对dp数组求和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] - nums[i<span class="number">-1</span>] == nums[i<span class="number">-1</span>] - nums[i<span class="number">-2</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基本动态规划：二维"><a href="#基本动态规划：二维" class="headerlink" title="基本动态规划：二维"></a>基本动态规划：二维</h3><h4 id="64-Minimum-Path-Sum-Medium"><a href="#64-Minimum-Path-Sum-Medium" class="headerlink" title="64. Minimum Path Sum (Medium)"></a>64. Minimum Path Sum (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个m * n大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最小的路径。每次只能向右或者向下移动。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维数组，输出是最优路径的数字和。</p><blockquote><p>Input:<br>[[1,3,1],<br>[1,5,1],<br>[4,2,1]]<br>Output: 7</p></blockquote><p>在这个样例中，最短路径为1-&gt;3-&gt;1-&gt;1-&gt;1。</p></li><li><p><strong>题解</strong></p><p>我们可以定义一个同样是二维的dp数组，其中dp[i][j]表示从左上角开始到(i, j)位置的最优路径的数字和。因为每次只能向下或者向右移动，我们可以很容易得到状态转移方程dp[i][j] &#x3D;min(dp[i-1][j], dp[i][j-1]) + grid[i][j]，其中grid表示原数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 dp 矩阵的每一个值只和左边和上面的值相关，我们可以使用空间压缩将 dp 数组压缩为一维。对于第 i 行，在遍历到第 j 列的时候，因为第 j-1 列已经更新过了，所以 dp[j-1] 代表 dp[i][j-1]的值；而 dp[j] 待更新，当前存储的值是在第 i-1 行的时候计算的，所以代表 dp[i-1][j] 的值。</p><p><font color=#FF0000 >注意</font> <font face="楷体" >如果不是很熟悉空间压缩技巧，笔者推荐您优先尝试写出非空间压缩的解法，如果时间充裕且力所能及再进行空间压缩。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j] + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="542-01-Matrix-Medium"><a href="#542-01-Matrix-Medium" class="headerlink" title="542. 01 Matrix (Medium)"></a>542. 01 Matrix (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维0-1数组，输出是一个同样大小的非负整数数组，表示每个位置到最近的0的距离。</p><blockquote><p>Input:<br>[[0,0,0],<br>[0,1,0],<br>[1,1,1]]<br>Output:<br>[[0,0,0],<br>[0,1,0],<br>[1,2,1]]</p></blockquote></li><li><p><strong>题解</strong></p><p>一般来说，因为这道题涉及到四个方向上的最近搜索，所以很多人的第一反应可能会是广度优先搜索。但是对于一个大小O(mn) 的二维数组，对每个位置进行四向搜索，最坏情况的时间复杂度（即全是 1 ）会达到恐怖的O(m2n2)。一种办法是使用一个dp数组做memoization，使得广度优先搜索不会重复遍历相同位置；另一种更简单的方法是，我们从左上到右下进行一次动态搜索，再从右下到左上进行一次动态搜索。两次动态搜索即可完成四个方向上的查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, INT_MAX - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i<span class="number">-1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; m - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i+<span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="221-Maximal-Square-Medium"><a href="#221-Maximal-Square-Medium" class="headerlink" title="221. Maximal Square (Medium)"></a>221. Maximal Square (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个二维的0-1矩阵，求全由 1 构成的最大正方形面积。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维0-1数组，输出是最大正方形面积。</p><blockquote><p>Input:<br>[[“1”,”0”,”1”,”0”,”0”],<br>[“1”,”0”,”1”,”1”,”1”],<br>[“1”,”1”,”1”,”1”,”1”],<br>[“1”,”0”,”0”,”1”,”0”]]<br>Output: 4</p></blockquote></li><li><p><strong>题解</strong></p><p>对于在矩阵内搜索正方形或长方形的题型，一种常见的做法是定义一个二维 dp 数组，其中dp[i][j] 表示满足题目条件的、以 (i, j) 为右下角的正方形或者长方形的属性。对于本题，则表示以 (i, j) 为右下角的全由 1 构成的最大正方形面积。如果当前位置是 0，那么 dp[i][j] 即为 0；如果当前位置是 1，我们假设 dp[i][j] &#x3D; k2，其充分条件为 dp[i-1][j-1]、dp[i][j-1] 和 dp[i-1][j] 的值必须都不小于 (k − 1)2，否则 (i, j) 位置不可以构成一个边长为 k 的正方形。同理，如果这三个值中的的最小值为 k − 1，则 (i, j) 位置一定且最大可以构成一个边长为 k 的正方形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), max_side = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == ’<span class="number">1</span>’) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max_side = <span class="built_in">max</span>(max_side, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_side * max_side;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分割类型题"><a href="#分割类型题" class="headerlink" title="分割类型题"></a>分割类型题</h3><h4 id="279-Perfect-Squares-Medium"><a href="#279-Perfect-Squares-Medium" class="headerlink" title="279. Perfect Squares (Medium)"></a>279. Perfect Squares (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个正整数，求其最少可以由几个完全平方数相加构成。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是给定的正整数，输出也是一个正整数，表示输入的数字最少可以由几个完全平方数相加构成。</p><blockquote><p>Input: n &#x3D; 13<br>Output: 2</p></blockquote><p>在这个样例中， 13 的最少构成方法为4+9。</p></li><li><p><strong>题解</strong></p><p>对于分割类型题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足分割条件的位置。我们定义一个一维矩阵dp，其中dp[i]表示数字i最少可以由几个完全平方数相加构成。在本题中，位置i只依赖i - k^2 的位置，如i - 1、i - 4、i - 9等等，才能满足完全平方分割的条件。因此dp[i]可以取的最小值即为1 + min(dp[i-1], dp[i-4], dp[i-9])。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; ++j) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i-j*j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="91-Decode-Ways-Medium"><a href="#91-Decode-Ways-Medium" class="headerlink" title="91. Decode Ways (Medium)"></a>91. Decode Ways (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>已知字母A-Z可以表示成数字1-26。给定一个数字串，求有多少种不同的字符串等价于这个数字串。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个由数字组成的字符串，输出是满足条件的解码方式总数。</p><blockquote><p>Input: “226”<br>Output: 3</p></blockquote><p>在这个样例中，有三种解码方式：BZ(2 26)、VF(22 6)或BBF(2 2 6)。</p></li><li><p><strong>题解</strong></p><p>这是一道很经典的动态规划题，难度不大但是十分考验耐心。这是因为只有1-26可以表示字母，因此对于一些特殊情况，比如数字 0 或者当相邻两数字大于 26 时，需要有不同的状态转移方程，详见如下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> prev = s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!prev) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> cur = s[i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((prev == <span class="number">0</span> || prev &gt; <span class="number">2</span>) &amp;&amp; cur == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((prev &lt; <span class="number">2</span> &amp;&amp; prev &gt; <span class="number">0</span>) || prev == <span class="number">2</span> &amp;&amp; cur &lt; <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-2</span>] + dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        prev = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="139-Word-Break-Medium"><a href="#139-Word-Break-Medium" class="headerlink" title="139. Word Break (Medium)"></a>139. Word Break (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字符串都可以在集合内找到。</p></li><li><p><strong>输入输出样例</strong></p><blockquote><p>Input: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br>Output: true</p></blockquote><p>在这个样例中，字符串可以被分割为[“apple”,“pen”,“apple”]。</p></li><li><p><strong>题解</strong></p><p>类似于完全平方数分割问题，这道题的分割条件由集合内的字符串决定，因此在考虑每个分割位置时，需要遍历字符串集合，以确定当前位置是否可以成功分割。注意对于位置 0 ，需要初始化值为真。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string &amp; word: wordDict) &#123;</span><br><span class="line">            <span class="type">int</span> len = word.<span class="built_in">length</span>();</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= len &amp;&amp; s.<span class="built_in">substr</span>(i - len, len) == word) &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - len];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h3><h4 id="300-Longest-Increasing-Subsequence-Medium"><a href="#300-Longest-Increasing-Subsequence-Medium" class="headerlink" title="300. Longest Increasing Subsequence (Medium)"></a>300. Longest Increasing Subsequence (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个未排序的整数数组，求最长的递增子序列。</p><p><font color=#FF0000 >注意</font> <font face="楷体" >按照LeetCode的习惯，子序列（subsequence）不必连续，子数组（subarray）或子字符串（substring）必须连续。</font></p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个一维数组，输出是一个正整数，表示最长递增子序列的长度。</p><blockquote><p>Input: [10,9,2,5,3,7,101,18]<br>Output: 4</p></blockquote><p>在这个样例中，最长递增子序列之一是[2,3,7,18]。</p></li><li><p><strong>题解</strong></p><p>对于子序列问题，第一种动态规划方法是，定义一个dp数组，其中dp[i]表示以i结尾的子序列的性质。在处理好每个位置后，统计一遍各个位置的结果即可得到题目要求的结果。</p><p>在本题中，dp[i]可以表示以i结尾的、最长子序列长度。对于每一个位置i，如果其之前的某个位置j所对应的数字小于位置i所对应的数字，则我们可以获得一个以i结尾的、长度为dp[j]+1的子序列。为了遍历所有情况，我们需要i和j进行两层循环，其时间复杂度为 O(n2)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max_length = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题还可以使用二分查找将时间复杂度降低为O¹nlognº。我们定义一个dp数组，其中dp[k]存储长度为k+1的最长递增子序列的最后一个数字。我们遍历每一个位置i，如果其对应的数字大于dp数组中所有数字的值，那么我们把它放在dp数组尾部，表示最长递增子序列长度加 1 ；如果我们发现这个数字在dp数组中比数字a大、比数字b小，则我们将b更新为此数字，使得之后构成递增序列的可能性增大。以这种方式维护的dp数组永远是递增的，因此可以用二分查找加速搜索。</p><p>以样例为例，对于数组[10,9,2,5,3,7,101,18]，我们每轮的更新查找情况为：</p><blockquote><p>num dp<br>10 [10]<br>9 [10]<br>2 [2]<br>5 [2]<br>3 [2,3]<br>7 [2,3,7]<br>101 [2,3,7,101]<br>18 [2,3,7,18]</p></blockquote><p>最终我们就获得了[2,3,7,18]这个最长递增数组之一。该算法的代码实现如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">    dp.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp.<span class="built_in">back</span>() &lt; nums[i]) &#123;</span><br><span class="line">            dp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> itr = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), nums[i]);</span><br><span class="line">            *itr = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1143-Longest-Commom-Subsequence-Medium"><a href="#1143-Longest-Commom-Subsequence-Medium" class="headerlink" title="1143. Longest Commom Subsequence (Medium)"></a>1143. Longest Commom Subsequence (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定两个字符串，求它们最长的公共子序列长度。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是两个字符串，输出是一个整数，表示它们满足题目条件的长度。</p><blockquote><p>Input: text1 &#x3D; “abcde”, text2 &#x3D; “ace”<br>Output: 3</p></blockquote><p>在这个样例中，最长公共子序列是“ace”。</p></li><li><p><strong>题解</strong></p><p>对于子序列问题，第二种动态规划方法是，定义一个dp数组，其中dp[i]表示到位置i为止的子序列的性质，并不必须以i结尾。这样dp数组的最后一位结果即为题目所求，不需要再对每个位置进行统计。</p><p>在本题中，我们可以建立一个二维数组dp，其中dp[i][j]表示到第一个字符串位置i为止、到第二个字符串位置j为止、最长的公共子序列长度。这样一来我们就可以很方便地分情况讨论这两个位置对应的字母相同与不同的情况了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>背包问题是一种组合优化的NP完全问题：有N个物品和容量为W的背包，每个物品都有自己的体积w和价值v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为0-1背包问题；如果不限定每种物品的数量，则问题称为无界背包问题或完全背包问题。</p><p>我们可以用动态规划来解决背包问题。以0-1背包问题为例。我们可以定义一个二维数组dp存储最大价值，其中dp[i][j]表示前i件物品体积不超过j的情况下能达到的最大价值。在我们遍历到第i件物品时，在当前背包总容量为j的情况下，如果我们不将物品i放入背包，那么dp[i][j]&#x3D; dp[i-1][j]，即前i个物品的最大价值等于只取前i-1个物品时的最大价值；如果我们将物品i放入背包，假设第i件物品体积为w，价值为v，那么我们得到dp[i][j] &#x3D; dp[i-1][j-w] + v。我们只需在遍历过程中对这两种情况取最大值即可，总时间复杂度和空间复杂度都为 O(NW)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= W; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w] + v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以进一步对 0-1 背包进行空间优化，将空间复杂度降低为 O(W)。如图所示，假设我们目前考虑物品 i &#x3D; 2，且其体积为 w &#x3D; 2，价值为 v &#x3D; 3；对于背包容量 j，我们可以得到 dp[2][j] &#x3D; max(dp[1][j], dp[1][j-2] + 3)。这里可以发现我们永远只依赖于上一排 i &#x3D; 1 的信息，之前算过的其他物品都不需要再使用。因此我们可以去掉 dp 矩阵的第一个维度，在考虑物品 i 时变成 dp[j] &#x3D; max(dp[j], dp[j-w] + v)。这里要注意我们在遍历每一行的时候必须逆向遍历，这样才能够调用上一行物品 i-1 时 dp[j-w] 的值；若按照从左往右的顺序进行正向遍历，则 dp[j-w] 的值在遍历到j之前就已经被更新成物品 i 的值了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = W; j &gt;= w; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w] + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完全背包问题中，一个物品可以拿多次。如图上半部分所示，假设我们遍历到物品 i &#x3D; 2，且其体积为 w &#x3D; 2，价值为 v &#x3D; 3；对于背包容量 j &#x3D; 5，最多只能装下 2 个该物品。那么我们的状态转移方程就变成了 dp[2][5] &#x3D; max(dp[1][5], dp[1][3] + 3, dp[1][1] + 6)。如果采用这种方法，假设背包容量无穷大而物体的体积无穷小，我们这里的比较次数也会趋近于无穷大，远超 O(NW) 的时间复杂度。</p><p>怎么解决这个问题呢？我们发现在 dp[2][3] 的时候我们其实已经考虑了 dp[1][3] 和 dp[2][1]的情况，而在时 dp[2][1] 也已经考虑了 dp[1][1] 的情况。因此，如图下半部分所示，对于拿多个物品的情况，我们只需考虑 dp[2][3] 即可，即 dp[2][5] &#x3D; max(dp[1][5], dp[2][3] + 3)。这样，我们就得到了完全背包问题的状态转移方程：dp[i][j] &#x3D; max(dp[i-1][j], dp[i][j-w] + v)，其与 0-1 背包问题的差别仅仅是把状态转移方程中的第二个 i-1 变成了 i。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= W; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j-w] + v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们也可以利用空间压缩将时间复杂度降低为 O(W)。这里要注意我们在遍历每一行的时候必须正向遍历，因为我们需要利用当前物品在第 j-w 列的信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> N, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = w; j &lt;= W; ++j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w] + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=#FF0000 >注意</font> <font face="楷体" >压缩空间时到底需要正向还是逆向遍历呢？物品和体积哪个放在外层，哪个放在内层呢？这取决于状态转移方程的依赖关系。在思考空间压缩前，不妨将状态转移矩阵画出来，方便思考如何进行空间压缩。</font></p><p><font face = "楷体">如果您实在不想仔细思考，这里有个简单的口诀：0-1背包对物品的迭代放在外层，里层的体积或价值逆向遍历；完全背包对物品的迭代放在里层，外层的体积或价值正向遍历。</font></p><h4 id="416-Partition-Equal-Subset-Sum-Medium"><a href="#416-Partition-Equal-Subset-Sum-Medium" class="headerlink" title="416. Partition Equal Subset Sum (Medium)"></a>416. Partition Equal Subset Sum (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个正整数数组，求是否可以把这个数组分成和相等的两部分。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个一维正整数数组，输出时一个布尔值，表示是否可以满足题目要求。</p><blockquote><p>Input: [1,5,11,5]<br>Output: true</p></blockquote><p>在这个样例中，满足条件的分割方法是[1,5,5]和[11]。</p></li><li><p><strong>题解</strong></p><p>本题等价于0-1背包问题，设所有数字和为sum，我们的目标是选取一部分物品，使得它们的总和为sum&#x2F;2。这道题不需要考虑价值，因此我们只需要通过一个布尔值矩阵来表示状态转移矩阵。注意边界条件的处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / <span class="number">2</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(target + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = nums[i<span class="number">-1</span>]; j &lt;= target; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们也可以对本题进行空间压缩。注意对数字和的遍历需要逆向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / <span class="number">2</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= nums[i<span class="number">-1</span>]; --j) &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j-nums[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="474-Ones-and-Zeroes-Medium"><a href="#474-Ones-and-Zeroes-Medium" class="headerlink" title="474. Ones and Zeroes (Medium)"></a>474. Ones and Zeroes (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定m个数字 0 和n个数字 1 ，以及一些由0-1构成的字符串，求利用这些数字最多可以构成多少个给定的字符串，字符串只可以构成一次。</p></li><li><p><strong>输入输出样例</strong></p><p>输入两个整数m和n，表示 0 和 1 的数量，以及一个一维字符串数组，表示待构成的字符串；输出是一个整数，表示最多可以生成的字符串个数。</p><blockquote><p>Input: Array &#x3D; {“10”, “0001”, “111001”, “1”, “0”}, m &#x3D; 5, n &#x3D; 3<br>Output: 4</p></blockquote><p>在这个样例中，我们可以用 5 个 0 和 3 个 1 构成[“ 10 ”,“ 0001 ”,“ 1 ”,“ 0 ”]。</p></li><li><p><strong>题解</strong></p><p>这是一个多维费用的0-1背包问题，有两个背包大小，0的数量和1的数量。我们在这里直接展示三维空间压缩到二维后的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> string &amp; str: strs) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [count0, count1] = <span class="built_in">count</span>(str);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= count0; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= count1; --j) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], <span class="number">1</span> + dp[i-count0][j-count1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="type">const</span> string &amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count0 = s.<span class="built_in">length</span>(), count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp; c: s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == ’<span class="number">1</span>’) &#123;</span><br><span class="line">            ++count1;</span><br><span class="line">            --count0;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(count0, count1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="322-Coin-Change-Medium"><a href="#322-Coin-Change-Medium" class="headerlink" title="322. Coin Change (Medium)"></a>322. Coin Change (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个一维整数数组，表示硬币的面额；以及一个整数，表示给定的金额。输出一个整数，表示满足条件的最少的硬币数量。若不存在解，则返回-1。</p><blockquote><p>Input: coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>Output: 3</p></blockquote><p>在这个样例中，最少的组合方法是11 &#x3D; 5 + 5 + 1。</p></li><li><p><strong>题解</strong></p><p>因为每个硬币可以用无限多次，这道题本质上是完全背包。我们直接展示二维空间压缩为一维的写法。</p><p>这里注意，我们把dp数组初始化为amount + 2而不是-1的原因是，在动态规划过程中有求最小值的操作，如果初始化成-1则会导致结果始终为-1。至于为什么取这个值，是因为i最大可以取amount + 1，而最多的组成方式是只用 1 元硬币，因此amount + 2一定大于所有可能的组合方式，取最小值时一定不会是它。在动态规划完成后，若结果仍然是此值，则说明不存在满足条件的组合方法，返回-1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coins.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">2</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount + <span class="number">2</span>? <span class="number">-1</span>: dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h3><h4 id="72-Edit-Distance-Hard"><a href="#72-Edit-Distance-Hard" class="headerlink" title="72. Edit Distance (Hard)"></a>72. Edit Distance (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可以将两个字符串变成相同。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是两个字符串，输出是一个整数，表示最少的步骤。</p><blockquote><p>Input: word1 &#x3D; “horse”, word2 &#x3D; “ros”<br>Output: 3</p></blockquote><p>在这个样例中，一种最优编辑方法是（1）horse -&gt; rorse （2）rorse -&gt; rose（3）rose -&gt; ros。</p></li><li><p><strong>题解</strong></p><p>类似于题目 1143 ，我们使用一个二维数组dp[i][j]，表示将第一个字符串到位置i为止，和第二个字符串到位置j为止，最多需要几步编辑。当第i位和第j位对应的字符相同时，dp[i][j]等于dp[i-1][j-1]；当二者对应的字符不同时，修改的消耗是dp[i-1][j-1]+1，插入i位置&#x2F;删除j位置的消耗是dp[i][j-1] + 1，插入j位置&#x2F;删除i位置的消耗是dp[i-1][j] + 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(</span><br><span class="line">                    dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + ((word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])? <span class="number">0</span>: <span class="number">1</span>),</span><br><span class="line">                    <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j] + <span class="number">1</span>, dp[i][j<span class="number">-1</span>] + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="650-2-Keys-Keyboard-Medium"><a href="#650-2-Keys-Keyboard-Medium" class="headerlink" title="650. 2 Keys Keyboard (Medium)"></a>650. 2 Keys Keyboard (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个字母A，已知你可以每次选择复制全部字符，或者粘贴之前复制的字符，求最少需要几次操作可以把字符串延展到指定长度。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个正整数，代表指定长度；输出是一个整数，表示最少操作次数。</p><blockquote><p>Input: 3<br>Output: 3</p></blockquote><p>在这个样例中，一种最优的操作方法是先复制一次，再粘贴两次。</p></li><li><p><strong>题解</strong></p><p>不同于以往通过加减实现的动态规划，这里需要乘除法来计算位置，因为粘贴操作是倍数增加的。我们使用一个一维数组dp，其中位置i表示延展到长度i的最少操作次数。对于每个位置j，如果j可以被i整除，那么长度i就可以由长度j操作得到，其操作次数等价于把一个长度为 1的A延展到长度为i&#x2F;j。因此我们可以得到递推公式dp[i] &#x3D; dp[j] + dp[i&#x2F;j]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSteps</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> h = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= h; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = dp[j] + dp[i/j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-Regular-Expression-Matching-Hard"><a href="#10-Regular-Expression-Matching-Hard" class="headerlink" title="10. Regular Expression Matching (Hard)"></a>10. Regular Expression Matching (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个字符串和一个正则表达式（regular expression, regex），求该字符串是否可以被匹配。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个待匹配字符串和一个用字符串表示的正则表达式，输出是一个布尔值，表示是否可以匹配成功。</p><blockquote><p>Input: s &#x3D; “aab”, p &#x3D; “c<em>a</em>b”<br>Output: true</p></blockquote><p>在个样例中，我们可以重复c零次，重复a两次。</p></li><li><p><strong>题解</strong></p><p>我们可以使用一个二维数组dp，其中dp[i][j]表示以i截止的字符串是否可以被以j截止的正则表达式匹配。根据正则表达式的不同情况，即字符、星号，点号，我们可以分情况讨论来更新dp数组，其具体代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i<span class="number">-1</span>] == ’*’) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j<span class="number">-1</span>] == ’.’) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[j<span class="number">-1</span>] != ’*’) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; p[j<span class="number">-1</span>] == s[i<span class="number">-1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[j<span class="number">-2</span>] != s[i<span class="number">-1</span>] &amp;&amp; p[j<span class="number">-2</span>] != ’.’) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>] || dp[i<span class="number">-1</span>][j] || dp[i][j<span class="number">-2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="股票交易"><a href="#股票交易" class="headerlink" title="股票交易"></a>股票交易</h3><p>股票交易类问题通常可以用动态规划来解决。对于稍微复杂一些的股票交易类问题，比如需要冷却时间或者交易费用，则可以用通过动态规划实现的状态机来解决。</p><h4 id="121-Best-Time-to-Buy-and-Sell-Stock-Easy"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy" class="headerlink" title="121. Best Time to Buy and Sell Stock (Easy)"></a>121. Best Time to Buy and Sell Stock (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一段时间内每天的股票价格，已知你只可以买卖各一次，求最大的收益。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。</p><blockquote><p>Input: [7,1,5,3,6,4]<br>Output: 5</p></blockquote><p>在这个样例中，最大的利润为在第二天价格为 1 时买入，在第五天价格为 6 时卖出。</p></li><li><p><strong>题解</strong></p><p>我们可以遍历一遍数组，在每一个位置i时，记录i位置之前所有价格中的最低价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sell = <span class="number">0</span>, buy = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        buy = <span class="built_in">max</span>(buy, -prices[i]);</span><br><span class="line">        sell = <span class="built_in">max</span>(sell, buy + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="188-Best-Time-to-Buy-and-Sell-Stock-IV-Hard"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV-Hard" class="headerlink" title="188. Best Time to Buy and Sell Stock IV (Hard)"></a>188. Best Time to Buy and Sell Stock IV (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一段时间内每天的股票价格，已知你只可以买卖各k次，且每次只能拥有一支股票，求最大的收益。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个一维整数数组，表示每天的股票价格；以及一个整数，表示可以买卖的次数k。输出一个整数，表示最大的收益。</p><blockquote><p>Input: [3,2,6,5,0,3], k &#x3D; 2<br>Output: 7</p></blockquote><p>在这个样例中，最大的利润为在第二天价格为 2 时买入，在第三天价格为 6 时卖出；再在第五天价格为 0 时买入，在第六天价格为 3 时卖出。</p></li><li><p><strong>题解</strong></p><p>如果k大约总天数，那么我们一旦发现可以赚钱就进行买卖。如果k小于总天数，我们可以建立两个动态规划数组buy和sell，对于每天的股票价格，buy[j]表示在第j次买入时的最大收益，sell[j]表示在第j次卖出时的最大收益。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> days = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (days &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= days) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxProfitUnlimited</span>(prices);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(k + <span class="number">1</span>, INT_MIN)</span>, <span class="title">sell</span><span class="params">(k + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; days; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">            buy[j] = <span class="built_in">max</span>(buy[j], sell[j<span class="number">-1</span>] - prices[i]);</span><br><span class="line">            sell[j] = <span class="built_in">max</span>(sell[j], buy[j] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfitUnlimited</span><span class="params">(vector&lt;<span class="type">int</span>&gt; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            maxProfit += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown-Medium"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown-Medium" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown (Medium)"></a>309. Best Time to Buy and Sell Stock with Cooldown (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一段时间内每天的股票价格，已知每次卖出之后必须冷却一天，且每次只能拥有一支股票，求最大的收益。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。</p><blockquote><p>Input: [1,2,3,0,2]<br>Output: 3</p></blockquote><p>在这个样例中，最大的利润获取操作是买入、卖出、冷却、买入、卖出。</p></li><li><p><strong>题解</strong></p><p>我们可以使用状态机来解决这类复杂的状态转移问题，通过建立多个状态以及它们的转移方式，我们可以很容易地推导出各个状态的转移方程。如图所示，我们可以建立四个状态来表示带有冷却的股票交易，以及它们的之间的转移方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(n)</span>, <span class="title">sell</span><span class="params">(n)</span>, <span class="title">s1</span><span class="params">(n)</span>, <span class="title">s2</span><span class="params">(n)</span></span>;</span><br><span class="line">    s1[<span class="number">0</span>] = buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    sell[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        buy[i] = s2[i<span class="number">-1</span>] - prices[i];</span><br><span class="line">        s1[i] = <span class="built_in">max</span>(buy[i<span class="number">-1</span>], s1[i<span class="number">-1</span>]);</span><br><span class="line">        sell[i] = <span class="built_in">max</span>(buy[i<span class="number">-1</span>], s1[i<span class="number">-1</span>]) + prices[i];</span><br><span class="line">        s2[i] = <span class="built_in">max</span>(s2[i<span class="number">-1</span>], sell[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(sell[n<span class="number">-1</span>], s2[n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II (Medium)</a></p><p><a href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray (Easy)</a></p><p><a href="https://leetcode.com/problems/integer-break/">343. Integer Break (Medium)</a></p><p><a href="https://leetcode.com/problems/delete-operation-for-two-strings/">583. Delete Operation for Two Strings (Medium)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/">646. Maximum Length of Pair Chain (Medium)</a></p><p><a href="https://leetcode.com/problems/wiggle-subsequence/">376. Wiggle Subsequence (Medium)</a></p><p><a href="https://leetcode.com/problems/target-sum/">494. Target Sum (Medium)</a></p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</a></p></li></ul><h2 id="第-8-章-化繁为简的分治法"><a href="#第-8-章-化繁为简的分治法" class="headerlink" title="第 8 章 化繁为简的分治法"></a>第 8 章 化繁为简的分治法</h2><h3 id="算法解释-5"><a href="#算法解释-5" class="headerlink" title="算法解释"></a>算法解释</h3><p>顾名思义，分治问题由“分”（divide）和“治”（conquer）两部分组成，通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。我们在排序章节展示的归并排序就是典型的分治问题，其中“分”即为把大数组平均分成两个小数组，通过递归实现，最终我们会得到多个长度为 1 的子数组;“治”即为把已经排好序的两个小数组合成为一个排好序的大数组，从长度为 1 的子数组开始，最终合成一个大数组。</p><p>我们也使用数学表达式来表示这个过程。定义 T(n) 表示处理一个长度为 n 的数组的时间复杂度，则归并排序的时间复杂度递推公式为 T(n) &#x3D; 2T(n&#x2F;2) + O(n)。其中 2T(n&#x2F;2) 表示我们分成了两个长度减半的子问题，O(n) 则为合并两个长度为 n&#x2F;2 数组的时间复杂度。</p><p>那么怎么利用这个递推公式得到最终的时间复杂度呢？这里我们可以利用著名的主定理（Master theorem）求解：</p><blockquote><p>考虑 T(n) &#x3D; aT(n&#x2F;b) + f (n)，定义 k &#x3D; logb a</p><ol><li>如果 f (n) &#x3D; O(n^p) 且 p &lt; k，那么 T(n) &#x3D; O(n^K) \frac{a}{b}</li><li>如果存在 c ≥ 0 满足 f (n) &#x3D; O(n^k log^c n)，那么 T(n) &#x3D; O(nk log^(c+1) n)</li><li>如果 f (n) &#x3D; O(n^p) 且 p &gt; k，那么 T(n) &#x3D; O( f (n))</li></ol></blockquote><p>通过主定理我们可以知道，归并排序属于第二种情况，且时间复杂度为 O(nlogn)。其他的分治问题也可以通过主定理求得时间复杂度。</p><p>另外，自上而下的分治可以和memoization结合，避免重复遍历相同的子问题。如果方便推导，也可以换用自下而上的动态规划方法求解。</p><h3 id="表达式问题"><a href="#表达式问题" class="headerlink" title="表达式问题."></a>表达式问题.</h3><h4 id="241-Different-Ways-to-Add-Parentheses-Medium"><a href="#241-Different-Ways-to-Add-Parentheses-Medium" class="headerlink" title="241. Different Ways to Add Parentheses (Medium)"></a>241. Different Ways to Add Parentheses (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个只包含加、减和乘法的数学表达式，求通过加括号可以得到多少种不同的结果。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个字符串，表示数学表达式；输出是一个数组，存储所有不同的加括号结果。</p><blockquote><p>Input: “2-1-1”<br>Output: [0, 2]</p></blockquote><p>在这个样例中，有两种加括号结果：((2-1)-1) &#x3D; 0和(2-(1-1)) &#x3D; 2。</p></li><li><p><strong>题解</strong></p><p>利用分治思想，我们可以把加括号转化为，对于每个运算符号，先执行处理两侧的数学表达式，再处理此运算符号。注意边界情况，即字符串内无运算符号，只有数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ways;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> c = input[i];</span><br><span class="line">        <span class="keyword">if</span> (c == ’+’ || c == ’-’ || c == ’*’) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(<span class="number">0</span>, i));</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(i + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; l: left) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; r: right) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                        <span class="keyword">case</span> ’+’: ways.<span class="built_in">push_back</span>(l + r); <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> ’-’: ways.<span class="built_in">push_back</span>(l - r); <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> ’*’: ways.<span class="built_in">push_back</span>(l * r); <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ways.<span class="built_in">empty</span>()) ways.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input));</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，某些被divide的子字符串可能重复出现多次，因此我们可以用memoization来去重。或者与其我们从上到下用分治处理+memoization，不如直接从下到上用动态规划处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; ops;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> op = ’ ’;</span><br><span class="line">    <span class="function">istringstream <span class="title">ss</span><span class="params">(input + <span class="string">&quot;+&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; num &amp;&amp; ss &gt;&gt; op) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(num);</span><br><span class="line">        ops.<span class="built_in">push_back</span>(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                dp[j][i].<span class="built_in">push_back</span>(data[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; i; k += <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> left : dp[j][k]) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span> right : dp[k+<span class="number">1</span>][i]) &#123;</span><br><span class="line">                            <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">switch</span> (ops[k]) &#123;</span><br><span class="line">                                <span class="keyword">case</span> ’+’: val = left + right; <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> ’-’: val = left - right; <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> ’*’: val = left * right; <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            dp[j][i].<span class="built_in">push_back</span>(val);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/beautiful-array/">932. Beautiful Array (Medium)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/burst-balloons/">312. Burst Balloons (Hard)</a></p></li></ul><h2 id="第-9-章-巧解数学问题"><a href="#第-9-章-巧解数学问题" class="headerlink" title="第 9 章 巧解数学问题"></a>第 9 章 巧解数学问题</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>对于LeetCode上数量不少的数学题，我们尽量将其按照类型划分讲解。然而很多数学题的解法并不通用，我们也很难在几道题里把所有的套路讲清楚，因此我们只选择了几道经典或是典型的题目，供大家参考。</p><h3 id="公倍数与公因数"><a href="#公倍数与公因数" class="headerlink" title="公倍数与公因数"></a>公倍数与公因数</h3><p>利用辗转相除法，我们可以很方便地求得两个数的最大公因数（greatest common divisor，gcd）；将两个数相乘再除以最大公因数即可得到最小公倍数（least common multiple, lcm）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a% b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步地，我们也可以通过扩展欧几里得算法（extended gcd）在求得a和b最大公因数的同时，也得到它们的系数x和y，从而使ax + by &#x3D; gcd(a, b)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">xGCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x1, y1, gcd = <span class="built_in">xGCD</span>(b, a % b, x1, y1);</span><br><span class="line">    x = y1, y = x1 - (a / b) * y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p>质数又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。值得注意的是，每一个数都可以分解成质数的乘积。</p><h4 id="204-Count-Primes-Easy"><a href="#204-Count-Primes-Easy" class="headerlink" title="204. Count Primes (Easy)"></a>204. Count Primes (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个数字n，求小于n的质数的个数。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个整数，输出也是一个整数，表示小于输入数的质数的个数。</p><blockquote><p>Input: 10<br>Output: 4</p></blockquote><p>在这个样例中，小于 10 的质数只有[2,3,5,7]。</p></li><li><p><strong>题解</strong></p><p>埃拉托斯特尼筛法（Sieve of Eratosthenes，简称埃氏筛法）是非常常用的，判断一个整数是否是质数的方法。并且它可以在判断一个整数n时，同时判断所小于n的整数，因此非常适合这道题。其原理也十分易懂：从1到n遍历，假设当前遍历到m，则把所有小于n的、且是m的倍数的整数标为和数；遍历完成后，没有被标为和数的数字即为质数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">prime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> count = n - <span class="number">2</span>; <span class="comment">// 去掉不是质数的1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prime[j]) &#123;</span><br><span class="line">                    prime[j] = <span class="literal">false</span>;</span><br><span class="line">                    --count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用质数的一些性质，我们可以进一步优化该算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">prime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>, sqrtn = <span class="built_in">sqrt</span>(n), count = n / <span class="number">2</span>; <span class="comment">// 偶数一定不是质数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= sqrtn) &#123; <span class="comment">// 最小质因子一定小于等于开方数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; n; j += <span class="number">2</span> * i) &#123; <span class="comment">// 避免偶数和重复遍历</span></span><br><span class="line">            <span class="keyword">if</span> (prime[j]) &#123;</span><br><span class="line">                --count;</span><br><span class="line">                prime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt;= sqrtn &amp;&amp; !prime[i]); <span class="comment">// 避免偶数和重复遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数字处理"><a href="#数字处理" class="headerlink" title="数字处理"></a>数字处理</h3><h4 id="504-Base-7-Easy"><a href="#504-Base-7-Easy" class="headerlink" title="504. Base 7 (Easy)"></a>504. Base 7 (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个十进制整数，求它在七进制下的表示。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个整数，输出一个字符串，表示其七进制。</p><blockquote><p>Input: 100<br>Output: “202”</p></blockquote><p>在这个样例中， 100 的七进制表示法来源于101 &#x3D; 2 * 49 + 0 * 7 + 2 * 1。</p></li><li><p><strong>题解</strong></p><p>进制转换类型的题，通常是利用除法和取模（mod）来进行计算，同时也要注意一些细节，如负数和零。如果输出是数字类型而非字符串，则也需要考虑是否会超出整数上下界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">convertToBase7</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> is_negative = num &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_negative) num = -num;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        <span class="type">int</span> a = num / <span class="number">7</span>, b = num % <span class="number">7</span>;</span><br><span class="line">        ans = <span class="built_in">to_string</span>(b) + ans;</span><br><span class="line">        num = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_negative ? <span class="string">&quot;-&quot;</span> + ans: ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="172-Factorial-Trailing-Zeroes"><a href="#172-Factorial-Trailing-Zeroes" class="headerlink" title="172. Factorial Trailing Zeroes"></a>172. Factorial Trailing Zeroes</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个非负整数，判断它的阶乘结果的结尾有几个0。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个非负整数，输出一个非负整数，表示输入的阶乘结果的结尾有几个0。</p><blockquote><p>Input: 12<br>Output: 2</p></blockquote><p>在这个样例中，12 !&#x3D; 479001600的结尾有两个0。</p></li><li><p><strong>题解</strong></p><p>每个尾部的0由2 * 5 &#x3D; 10 而来，因此我们可以把阶乘的每一个元素拆成质数相乘，统计有多少个2和5。明显的，质因子2的数量远多于质因子5的数量，因此我们可以只统计阶乘结果里有多少个质因子5。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span>? <span class="number">0</span>: n / <span class="number">5</span> + <span class="built_in">trailingZeroes</span>(n / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="415-Add-Strings-Easy"><a href="#415-Add-Strings-Easy" class="headerlink" title="415. Add Strings (Easy)"></a>415. Add Strings (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定两个由数字组成的字符串，求它们相加的结果。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是两个字符串，输出是一个整数，表示输入的数字和。</p><blockquote><p>Input: num1 &#x3D; “99”, num2 &#x3D; “1”<br>Output: 100</p></blockquote></li><li><p><strong>题解</strong></p><p>因为相加运算是从后往前进行的，所以可以先翻转字符串，再逐位计算。这种类型的题考察的是细节，如进位、位数差等等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">output</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">reverse</span>(num1.<span class="built_in">begin</span>(), num1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(num2.<span class="built_in">begin</span>(), num2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> onelen = num1.<span class="built_in">length</span>(), twolen = num2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (onelen &lt;= twolen)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(num1, num2);</span><br><span class="line">        <span class="built_in">swap</span>(onelen, twolen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> addbit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; twolen; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> cur_sum = (num1[i]-’<span class="number">0</span>’) + (num2[i]-’<span class="number">0</span>’) + addbit;</span><br><span class="line">        output += <span class="built_in">to_string</span>((cur_sum) % <span class="number">10</span>);</span><br><span class="line">        addbit = cur_sum &lt; <span class="number">10</span>? <span class="number">0</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = twolen; i &lt; onelen; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> cur_sum = (num1[i]-’<span class="number">0</span>’) + addbit;</span><br><span class="line">        output += <span class="built_in">to_string</span>((cur_sum) % <span class="number">10</span>);</span><br><span class="line">        addbit = cur_sum &lt; <span class="number">10</span>? <span class="number">0</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addbit) &#123;</span><br><span class="line">        output += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(output.<span class="built_in">begin</span>(), output.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="326-Power-of-Three-Easy"><a href="#326-Power-of-Three-Easy" class="headerlink" title="326. Power of Three (Easy)"></a>326. Power of Three (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>判断一个数字是否是 3 的次方。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个整数，输出一个布尔值。</p><blockquote><p>Input: n &#x3D; 27<br>Output: true</p></blockquote></li><li><p><strong>题解</strong></p><p>有两种方法，一种是利用对数。设log3n &#x3D;m，如果n是3的整数次方，那么m一定是整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fmod</span>(<span class="built_in">log10</span>(n) / <span class="built_in">log10</span>(<span class="number">3</span>), <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是，因为在int范围内 3 的最大次方是 3^19 &#x3D; 1162261467 ，如果n是3的整数次方，那么 1162261467 除以n的余数一定是零；反之亦然。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="随机与取样"><a href="#随机与取样" class="headerlink" title="随机与取样"></a>随机与取样</h3><h4 id="384-Shuffle-an-Array-Medium"><a href="#384-Shuffle-an-Array-Medium" class="headerlink" title="384. Shuffle an Array (Medium)"></a>384. Shuffle an Array (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个数组，要求实现两个指令函数。第一个函数“shuffle”可以随机打乱这个数组，第二个函数“reset”可以恢复原来的顺序。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个存有整数数字的数组，和一个包含指令函数名称的数组。输出是一个二维数组，表示每个指令生成的数组。</p><blockquote><p>Input: nums &#x3D; [1,2,3], actions: [“shuffle”,”shuffle”,”reset”]<br>Output: [[2,1,3],[3,2,1],[1,2,3]]</p></blockquote><p>在这个样例中，前两次打乱的结果只要是随机生成即可</p></li><li><p><strong>题解</strong></p><p>我们采用经典的Fisher-Yates洗牌算法，原理是通过随机交换位置来实现随机打乱，有正向和反向两种写法，且实现非常方便。注意这里“reset”函数以及类的构造函数的实现细节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; origin;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt; nums): <span class="built_in">origin</span>(std::<span class="built_in">move</span>(nums)) &#123;&#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (origin.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffled</span><span class="params">(origin)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = origin.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 可以使用反向或者正向洗牌，效果相同。</span></span><br><span class="line">        <span class="comment">// 反向洗牌：</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(shuffled[i], shuffled[<span class="built_in">rand</span>() % (i + <span class="number">1</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正向洗牌：</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//int pos = rand() % (n - i);</span></span><br><span class="line">        <span class="comment">//swap(shuffled[i], shuffled[i+pos]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> shuffled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="528-Random-Pick-with-Weight-Medium"><a href="#528-Random-Pick-with-Weight-Medium" class="headerlink" title="528. Random Pick with Weight (Medium)"></a>528. Random Pick with Weight (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个数组，数组每个位置的值表示该位置的权重，要求按照权重的概率去随机采样。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一维正整数数组，表示权重；和一个包含指令字符串的一维数组，表示运行几次随机采样。输出是一维整数数组，表示随机采样的整数在数组中的位置。</p><blockquote><p>Input: weights &#x3D; [1,3], actions: [“pickIndex”,”pickIndex”,”pickIndex”]<br>Output: [0,1,1]</p></blockquote><p>在这个样例中，每次选择的位置都是不确定的，但选择第0个位置的期望为1&#x2F;4，选择第1个位置的期望为3&#x2F;4。</p></li><li><p><strong>题解</strong></p><p>我们可以先使用partial_sum求前缀和（即到每个位置为止之前所有数字的和），这个结果对于正整数数组是单调递增的。每当需要采样时，我们可以先随机产生一个数字，然后使用二分法查找其在前缀和中的位置，以模拟加权采样的过程。这里的二分法可以用lower_bound实现。</p><p>以样例为例，权重数组[1,3]的前缀和为[1,4]。如果我们随机生成的数字为1，那么lower_bound返回的位置为0；如果我们随机生成的数字是2、3、4，那么lower_bound返回的位置为1。</p><p>关于前缀和的更多技巧，我们将在接下来的章节中继续深入讲解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt; weights): <span class="built_in">sums</span>(std::<span class="built_in">move</span>(weights)) &#123;</span><br><span class="line">        <span class="built_in">partial_sum</span>(sums.<span class="built_in">begin</span>(), sums.<span class="built_in">end</span>(), sums.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = (<span class="built_in">rand</span>() % sums.<span class="built_in">back</span>()) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lower_bound</span>(sums.<span class="built_in">begin</span>(), sums.<span class="built_in">end</span>(), pos) - sums.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="382-Linked-List-Random-Node-Medium"><a href="#382-Linked-List-Random-Node-Medium" class="headerlink" title="382. Linked List Random Node (Medium)"></a>382. Linked List Random Node (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个单向链表，要求设计一个算法，可以随机取得其中的一个数字。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个单向链表，输出是一个数字，表示链表里其中一个节点的值。</p><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5<br>Output: 3</p></blockquote><p>在这个样例中，我们有均等的概率得到任意一个节点，比如3。</p></li><li><p><strong>题解</strong></p><p>不同于数组，在未遍历完链表前，我们无法知道链表的总长度。这里我们就可以使用水库采样：遍历一次链表，在遍历到第m个节点时，有 1&#x2F;m 的概率选择这个节点覆盖掉之前的节点选择。</p><p>我们提供一个简单的，对于水库算法随机性的证明。对于长度为 n 的链表的第 m 个节点，最后被采样的充要条件是它被选择，且之后的节点都没有被选择。这种情况发生的概率为 1&#x2F;m × m&#x2F;(m+1) × (m+1)&#x2F;(m+2) × · · · × (n−1)&#x2F;n &#x3D; 1&#x2F;n。因此每个点都有均等的概率被选择。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode* head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode* n): <span class="built_in">head</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = head-&gt;val;</span><br><span class="line">        ListNode* node = head-&gt;next;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">rand</span>() % i) == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-7"><a href="#练习-7" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/excel-sheet-column-title/">168. Excel Sheet Column Title (Easy)</a></p><p><a href="https://leetcode.com/problems/add-binary/">67. Add Binary (Easy)</a></p><p><a href="https://leetcode.com/problems/product-of-array-except-self/">238. Product of Array Except Self (Medium)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/">462. Minimum Moves to Equal Array Elements II (Medium)</a></p><p><a href="https://leetcode.com/problems/majority-element/">169. Majority Element (Easy)</a></p><p><a href="https://leetcode.com/problems/implement-rand10-using-rand7/">470. Implement Rand10() Using Rand7() (Medium)</a></p><p><a href="https://leetcode.com/problems/happy-number/">202. Happy Number (Easy)</a></p></li></ul><h2 id="第-10-章-神奇的位运算"><a href="#第-10-章-神奇的位运算" class="headerlink" title="第 10 章 神奇的位运算"></a>第 10 章 神奇的位运算</h2><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><p>位运算是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。常用的位运算符号包括：“∧”按位异或、“&amp;”按位与、“|”按位或、“∼”取反、“&lt;&lt;”算术左移和“&gt;&gt;”算术右移。以下是一些常见的位运算特性，其中 0s 和 1s 分别表示只 0或1构成的二进制数字。</p><blockquote><p>x ^ 0s &#x3D; x<br>x &amp; 0s &#x3D; 0<br>x | 0s &#x3D; x<br>x ^ 1s &#x3D; ~x<br>x &amp; 1s &#x3D; x<br>x | 1s &#x3D; 1s<br>x ^ x &#x3D; 0<br>x &amp; x &#x3D; x<br>x | x &#x3D; x</p></blockquote><p>除此之外，n &amp; (n - 1) 可以去除 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，减去 1 得到 11110011，这两个数按位与得到 11110000。n &amp; (-n) 可以得到 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100。还有更多的并不常用的技巧，若读者感兴趣可以自行研究，这里不再赘述。</p><h3 id="位运算基础问题"><a href="#位运算基础问题" class="headerlink" title="位运算基础问题"></a>位运算基础问题</h3><h4 id="461-Hamming-Distance-Easy"><a href="#461-Hamming-Distance-Easy" class="headerlink" title="461. Hamming Distance (Easy)"></a>461. Hamming Distance (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定两个十进制数字，求它们二进制表示的汉明距离（Hamming distance，即不同位的个数）。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是两个十进制整数，输出是一个十进制整数，表示两个输入数字的汉明距离。</p><blockquote><p>Input: x &#x3D; 1, y &#x3D; 4<br>Output: 2</p></blockquote><p>在这个样例中，1的二进制是0001，4的二进制是0100，一共有两位不同。</p></li><li><p><strong>题解</strong></p><p>对两个数进行按位异或操作，统计有多少个1即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> diff = x ^ y, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (diff) &#123;</span><br><span class="line">        ans += diff &amp; <span class="number">1</span>;</span><br><span class="line">        diff &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="190-Reverse-Bits-Easy"><a href="#190-Reverse-Bits-Easy" class="headerlink" title="190. Reverse Bits (Easy)"></a>190. Reverse Bits (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个十进制整数，输出它在二进制下的翻转结果。</p></li><li><p><strong>输入输出样例</strong></p><p>输入和输出都是十进制整数。</p><blockquote><p>Input: 43261596 (00000010100101000001111010011100)<br>Output: 964176192 (00111001011110000010100101000000)</p></blockquote></li><li><p><strong>题解</strong></p><p>使用算术左移和右移，可以很轻易地实现二进制的翻转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        ans += n &amp; <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="136-Single-Number-Easy"><a href="#136-Single-Number-Easy" class="headerlink" title="136. Single Number (Easy)"></a>136. Single Number (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个整数数组，这个数组里只有一个数次出现了一次，其余数字出现了两次，求这个只出现一次的数字。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个一维整数数组，输出是该数组内的一个整数。</p><blockquote><p>Input: [4,1,2,1,2]<br>Output: 4</p></blockquote></li><li><p><strong>题解</strong></p><p>我们可以利用 x ∧ x &#x3D; 0 和 x ∧ 0 &#x3D; x 的特点，将数组内所有的数字进行按位异或。出现两次的所有数字按位异或的结果是 0，0 与出现一次的数字异或可以得到这个数字本身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num: nums) &#123;</span><br><span class="line">        ans ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二进制特性"><a href="#二进制特性" class="headerlink" title="二进制特性"></a>二进制特性</h3><p>利用二进制的一些特性，我们可以把位运算使用到更多问题上。</p><p>例如，我们可以利用二进制和位运算输出一个数组的所有子集。假设我们有一个长度为n的数组，我们可以生成长度为n的所有二进制， 1 表示选取该数字， 0 表示不选取。这样我们就获得了2^n个子集。</p><h4 id="342-Power-of-Four-Easy"><a href="#342-Power-of-Four-Easy" class="headerlink" title="342. Power of Four (Easy)"></a>342. Power of Four (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个整数，判断它是否是4的次方。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个整数，输出是一个布尔值，表示判断结果。</p><blockquote><p>Input: 16<br>Output: true</p></blockquote><p>在这个样例中，16是4的二次方，因此返回值为真。</p></li><li><p><strong>题解</strong></p><p>首先我们考虑一个数字是不是 2 的（整数）次方：如果一个数字 n 是 2 的整数次方，那么它的二进制一定是 0…010…0 这样的形式；考虑到 n − 1 的二进制是 0…001…1，这两个数求按位与的结果一定是 0。因此如果 n &amp; (n - 1) 为 0，那么这个数是 2 的次方。</p><p>如果这个数也是 4 的次方，那二进制表示中 1 的位置必须为奇数位。我们可以把 n 和二进制的 10101…101（即十进制下的 1431655765）做按位与，如果结果不为 0，那么说明这个数是 4 的次方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; !(n &amp; (n - <span class="number">1</span>)) &amp;&amp; (n &amp; <span class="number">1431655765</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="318-Maximum-Product-of-Word-Lengths-Medium"><a href="#318-Maximum-Product-of-Word-Lengths-Medium" class="headerlink" title="318. Maximum Product of Word Lengths (Medium)"></a>318. Maximum Product of Word Lengths (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定多个字母串，求其中任意两个字母串的长度乘积的最大值，且这两个字母串不能含有相同字母。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个包含多个字母串的一维数组，输出一个整数，表示长度乘积的最大值。</p><blockquote><p>Input: [“a”,”ab”,”abc”,”d”,”cd”,”bcd”,”abcd”]<br>Output: 4</p></blockquote><p>在这个样例中，一种最优的选择是“ab”和“cd”。</p></li><li><p><strong>题解</strong></p><p>怎样快速判断两个字母串是否含有重复数字呢？可以为每个字母串建立一个长度为 26 的二进制数字，每个位置表示是否存在该字母。如果两个字母串含有重复数字，那它们的二进制表示的按位与不为 0 。同时，我们可以建立一个哈希表来存储字母串（在数组的位置）到二进制数字的映射关系，方便查找调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> string &amp; word : words) &#123;</span><br><span class="line">        <span class="type">int</span> mask = <span class="number">0</span>, size = word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp; c : word) &#123;</span><br><span class="line">            mask |= <span class="number">1</span> &lt;&lt; (c - ’a’);</span><br><span class="line">        &#125;</span><br><span class="line">        hash[mask] = <span class="built_in">max</span>(hash[mask], size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [h_mask, h_len]: hash) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(mask &amp; h_mask)) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, size * h_len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="338-Counting-Bits-Medium"><a href="#338-Counting-Bits-Medium" class="headerlink" title="338. Counting Bits (Medium)"></a>338. Counting Bits (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个非负整数n，求从0到n的所有数字的二进制表达中，分别有多少个1。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个非负整数n，输出是长度为n + 1的非负整数数组，每个位置m表示m的二进制里有多少个1。</p><blockquote><p>Input: 5<br>Output: [0,1,1,2,1,2]</p></blockquote></li><li><p><strong>题解</strong></p><p>本题可以利用动态规划和位运算进行快速的求解。定义一个数组dp，其中dp[i]表示数字i的二进制含有 1 的个数。对于第i个数字，如果它二进制的最后一位为 1 ，那么它含有 1 的个数则为dp[i-1] + 1；如果它二进制的最后一位为 0 ，那么它含有 1 的个数和其算术右移结果相同，即dp[i&gt;&gt;1]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(num+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        dp[i] = i &amp; <span class="number">1</span>? dp[i<span class="number">-1</span>] + <span class="number">1</span>: dp[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 等价于dp[i] = dp[i&amp;(i-1)] + 1;</span></span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-8"><a href="#练习-8" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/missing-number/">268. Missing Number (Easy)</a></p><p><a href="https://leetcode.com/problems/binary-number-with-alternating-bits/">693. Binary Number with Alternating Bits (Easy)</a></p><p><a href="https://leetcode.com/problems/number-complement/">476. Number Complement (Easy)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/single-number-iii/">260. Single Number III (Medium)</a></p></li></ul><h2 id="第-11-章-妙用数据结构"><a href="#第-11-章-妙用数据结构" class="headerlink" title="第 11 章 妙用数据结构"></a>第 11 章 妙用数据结构</h2><h3 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h3><p>在刷题时，我们几乎一定会用到各种数据结构来辅助我们解决问题，因此我们必须熟悉各种数据结构的特点。C++ STL提供的数据结构包括（实际底层细节可能因编译器而异）：</p><ul><li>Sequence Containers：维持顺序的容器。<ul><li>vector：动态数组，是我们最常使用的数据结构之一，用于 O(1) 的随机读取。因为大部分算法的时间复杂度都会大于 O(n)，因此我们经常新建 vector 来存储各种数据或中间变量。因为在尾部增删的复杂度是 O(1)，我们也可以把它当作 stack 来用。</li><li>list：双向链表，也可以当作 stack 和 queue 来使用。由于 LeetCode 的题目多用 Node 来表示链表，且链表不支持快速随机读取，因此我们很少用到这个数据结构。一个例外是经典的 LRU 问题，我们需要利用链表的特性来解决，我们在后文会遇到这个问题。</li><li>deque：双端队列，这是一个非常强大的数据结构，既支持 O(1) 随机读取，又支持 O(1)时间的头部增删和尾部增删，不过有一定的额外开销。</li><li>array：固定大小的数组，一般在刷题时我们不使用。</li><li>forward_list：单向链表，一般在刷题时我们不使用</li></ul></li><li>Container Adaptors：基于其它容器实现的数据结构。<ul><li>stack：后入先出（LIFO）的数据结构，默认基于 deque 实现。stack 常用于深度优先搜索、一些字符串匹配问题以及单调栈问题。</li><li>queue：先入先出（FIFO）的数据结构，默认基于 deque 实现。queue 常用于广度优先搜索。</li><li>priority_queue：最大值先出的数据结构，默认基于vector实现堆结构。它可以在O(n log n)的时间排序数组，O(log n) 的时间插入任意值，O(1) 的时间获得最大值，O(log n) 的时间删除最大值。priority_queue 常用于维护数据结构并快速获取最大或最小值。</li></ul></li><li>Associative Containers：实现了排好序的数据结构。<ul><li>set：有序集合，元素不可重复，底层实现默认为红黑树，即一种特殊的二叉查找树（BST）。它可以在 O(n log n) 的时间排序数组，O(log n) 的时间插入、删除、查找任意值，O(log n) 的时间获得最小或最大值。这里注意，set 和 priority_queue 都可以用于维护数据结构并快速获取最大最小值，但是它们的时间复杂度和功能略有区别，如priority_queue 默认不支持删除任意值，而set 获得最大或最小值的时间复杂度略高，具体使用哪个根据需求而定。</li><li>multiset：支持重复元素的 set。</li><li>map：有序映射或有序表，在 set 的基础上加上映射关系，可以对每个元素 key 存一个值 value。</li><li>multimap：支持重复元素的 map。</li></ul></li><li>Unordered Associative Containers：对每个 Associative Containers 实现了哈希版本。<ul><li>unordered_set：哈希集合，可以在 O(1) 的时间快速插入、查找、删除元素，常用于快速的查询一个元素是否在这个容器内。</li><li>unordered_multiset：支持重复元素的 unordered_set。</li><li>unordered_map：哈希映射或哈希表，在 unordered_set 的基础上加上映射关系，可以对每一个元素 key 存一个值 value。在某些情况下，如果 key 的范围已知且较小，我们也可以用 vector 代替 unordered_map，用位置表示 key，用每个位置的值表示 value。</li><li>unordered_multimap：支持重复元素的 unordered_map。</li></ul></li></ul><p>因为这并不是一本讲解C++原理的书，更多的STL细节请读者自行搜索。只有理解了这些数据结构的原理和使用方法，才能够更加游刃有余地解决算法和数据结构问题。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="448-Find-All-Numbers-Disappeared-in-an-Array-Easy"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array-Easy" class="headerlink" title="448. Find All Numbers Disappeared in an Array (Easy)"></a>448. Find All Numbers Disappeared in an Array (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个长度为n的数组，其中包含范围为 1 到n的整数，有些整数重复了多次，有些整数没有出现，求 1 到n中没有出现过的整数。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个一维整数数组，输出也是一个一维整数数组，表示输入数组内没出现过的数字。</p><blockquote><p>Input: [4,3,2,7,8,2,3,1]<br>Output: [5,6]</p></blockquote></li><li><p><strong>题解</strong></p><p>利用数组这种数据结构建立n个桶，把所有重复出现的位置进行标记，然后再遍历一遍数组，即可找到没有出现过的数字。进一步地，我们可以直接对原数组进行标记：把重复出现的数字在原数组出现的位置设为负数，最后仍然为正数的位置即为没有出现过的数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num: nums) &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">abs</span>(num) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[pos] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[pos] = -nums[pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="48-Rotate-Image-Medium"><a href="#48-Rotate-Image-Medium" class="headerlink" title="48. Rotate Image (Medium)"></a>48. Rotate Image (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个n * n的矩阵，求它顺时针旋转 90 度的结果，且必须在原矩阵上修改（in-place）。怎样能够尽量不创建额外储存空间呢？</p></li><li><p><strong>输入输出样例</strong></p><p>输入和输出都是一个二维整数矩阵。</p><blockquote><p>Input:<br>[[1,2,3],<br>[4,5,6],<br>[7,8,9]]<br>Output:<br>[[7,4,1],<br>[8,5,2],<br>[9,6,3]]</p></blockquote></li><li><p><strong>题解</strong></p><p>每次只考虑四个间隔 90 度的位置，可以进行 O(1) 额外空间的旋转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>, n = matrix.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n - i; ++j) &#123;</span><br><span class="line">            temp = matrix[j][n-i];</span><br><span class="line">            matrix[j][n-i] = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n-j][i];</span><br><span class="line">            matrix[n-j][i] = matrix[n-i][n-j];</span><br><span class="line">            matrix[n-i][n-j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="240-Search-a-2D-Matrix-II-Medium"><a href="#240-Search-a-2D-Matrix-II-Medium" class="headerlink" title="240. Search a 2D Matrix II (Medium)"></a>240. Search a 2D Matrix II (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个二维矩阵，已知每行和每列都是增序的，尝试设计一个快速搜索一个数字是否在矩阵中存在的算法。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维整数矩阵，和一个待搜索整数。输出是一个布尔值，表示这个整数是否存在于矩阵中。</p><blockquote><p>Input: matrix &#x3D;<br>[ [1, 4, 7, 11, 15],<br>[2, 5, 8, 12, 19],<br>[3, 6, 9, 16, 22],<br>[10, 13, 14, 17, 24],<br>[18, 21, 23, 26, 30]], target &#x3D; 5<br>Output: true</p></blockquote></li><li><p><strong>题解</strong></p><p>这道题有一个简单的技巧：我们可以从右上角开始查找，若当前值大于待搜索值，我们向左移动一位；若当前值小于待搜索值，我们向下移动一位。如果最终移动到左下角时仍不等于待搜索值，则说明待搜索值不存在于矩阵中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="769-Max-Chunks-To-Make-Sorted-Medium"><a href="#769-Max-Chunks-To-Make-Sorted-Medium" class="headerlink" title="769. Max Chunks To Make Sorted (Medium)"></a>769. Max Chunks To Make Sorted (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个含有 0 到n整数的数组，每个整数只出现一次，求这个数组最多可以分割成多少个子数组，使得对每个子数组进行增序排序后，原数组也是增序的。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个一维整数数组，输出一个整数，表示最多的分割数。</p><blockquote><p>Input: [1,0,2,3,4]<br>Output: 4</p></blockquote><p>在这个样例中，最多分割是[1, 0], [2], [3], [4]。</p></li><li><p><strong>题解</strong></p><p>从左往右遍历，同时记录当前的最大值，每当当前最大值等于数组位置时，我们可以多一次分割。</p><p>为什么可以通过这个算法解决问题呢？如果当前最大值大于数组位置，则说明右边一定有小于数组位置的数字，需要把它也加入待排序的子数组；又因为数组只包含不重复的 0 到n，所以当前最大值一定不会小于数组位置。所以每当当前最大值等于数组位置时，假设为p，我们可以成功完成一次分割，并且其与上一次分割位置q之间的值一定是q + 1 到p的所有数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxChunksToSorted</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> chunks = <span class="number">0</span>, cur_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cur_max = <span class="built_in">max</span>(cur_max, arr[i]);</span><br><span class="line">        <span class="keyword">if</span> (cur_max == i) &#123;</span><br><span class="line">            ++chunks;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chunks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="232-Implement-Queue-using-Stacks-Easy"><a href="#232-Implement-Queue-using-Stacks-Easy" class="headerlink" title="232. Implement Queue using Stacks (Easy)"></a>232. Implement Queue using Stacks (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>尝试使用栈（stack）来实现队列（queue）。</p></li><li><p><strong>输入输出样例</strong></p><p>以下是数据结构的调用样例。</p><blockquote><p>MyQueue queue &#x3D; newMyQueue();</p><p>queue.push(1);</p><p>queue.push(2);</p><p>queue.peek(); &#x2F;&#x2F;returns 1</p><p>queue.pop(); &#x2F;&#x2F; returns 1</p><p>queue.empty(); &#x2F;&#x2F;returnsfalse</p></blockquote></li><li><p><strong>题解</strong></p><p>我们可以用两个栈来实现一个队列：因为我们需要得到先入先出的结果，所以必定要通过一个额外栈翻转一次数组。这个翻转过程既可以在插入时完成，也可以在取值时完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; in, out;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">in2out</span>();</span><br><span class="line">        <span class="type">int</span> x = out.<span class="built_in">top</span>();</span><br><span class="line">        out.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">in2out</span>();</span><br><span class="line">        <span class="keyword">return</span> out.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">in2out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (out.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> x = in.<span class="built_in">top</span>();</span><br><span class="line">                in.<span class="built_in">pop</span>();</span><br><span class="line">                out.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.<span class="built_in">empty</span>() &amp;&amp; out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="155-Min-Stack-Easy"><a href="#155-Min-Stack-Easy" class="headerlink" title="155. Min Stack (Easy)"></a>155. Min Stack (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>设计一个最小栈，除了需要支持常规栈的操作外，还需要支持在O¹ 1 º时间内查询栈内最小值的功能。</p></li><li><p><strong>输入输出样例</strong></p><p>以下是数据结构的调用样例。</p><blockquote><p>MinStack minStack &#x3D; newMinStack();</p><p>minStack.push(-2);</p><p>minStack.push(0);</p><p>minStack.push(-3);</p><p>minStack.getMin(); &#x2F;&#x2F;Returns-3.</p><p>minStack.pop();</p><p>minStack.top(); &#x2F;&#x2F; Returns0.</p><p>minStack.getMin(); &#x2F;&#x2F;Returns-2.</p></blockquote></li><li><p><strong>题解</strong></p><p>我们可以额外建立一个新栈，栈顶表示原栈里所有值的最小值。每当在原栈里插入一个数字时，若该数字小于等于新栈栈顶，则表示这个数字在原栈里是最小值，我们将其同时插入新栈内。每当从原栈里取出一个数字时，若该数字等于新栈栈顶，则表示这个数是原栈里的最小值之一，我们同时取出新栈栈顶的值。</p><p>一个写起来更简单但是时间复杂度略高的方法是，我们每次插入原栈时，都向新栈插入一次原栈里所有值的最小值（新栈栈顶和待插入值中小的那一个）；每次从原栈里取出数字时，同样取出新栈的栈顶。这样可以避免判断，但是每次都要插入和取出。我们这里只展示第一种写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s, min_s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (min_s.<span class="built_in">empty</span>() || min_s.<span class="built_in">top</span>() &gt;= x) &#123;</span><br><span class="line">            min_s.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!min_s.<span class="built_in">empty</span>() &amp;&amp; min_s.<span class="built_in">top</span>() == s.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            min_s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="20-Valid-Parentheses-Easy"><a href="#20-Valid-Parentheses-Easy" class="headerlink" title="20. Valid Parentheses (Easy)"></a>20. Valid Parentheses (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个只由左右原括号、花括号和方括号组成的字符串，求这个字符串是否合法。合法的定义是每一个类型的左括号都有一个右括号一一对应，且括号内的字符串也满足此要求。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个字符串，输出是一个布尔值，表示字符串是否合法。</p><blockquote><p>Input: “{ [ ] }()”<br>Output: true</p></blockquote></li><li><p><strong>题解</strong></p><p>括号匹配是典型的使用栈来解决的问题。我们从左往右遍历，每当遇到左括号便放入栈内，遇到右括号则判断其和栈顶的括号是否是统一类型，是则从栈内取出左括号，否则说明字符串不合法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; parsed;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == ’&#123;’ || s[i] == ’[’ || s[i] == ’(’) &#123;</span><br><span class="line">            parsed.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parsed.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> c = parsed.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> ((s[i] == ’&#125;’ &amp;&amp; c == ’&#123;’) ||</span><br><span class="line">                (s[i] == ’]’ &amp;&amp; c == ’[’) || </span><br><span class="line">                (s[i] == ’)’ &amp;&amp; c == ’(’)) &#123;</span><br><span class="line">                    parsed.<span class="built_in">pop</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> parsed.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈通过维持栈内值的单调递增（递减）性，在整体O(n)的时间内处理需要大小比较的问题。</p><h4 id="739-Daily-Temperatures-Medium"><a href="#739-Daily-Temperatures-Medium" class="headerlink" title="739. Daily Temperatures (Medium)"></a>739. Daily Temperatures (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定每天的温度，求对于每一天需要等几天才可以等到更暖和的一天。如果该天之后不存在更暖和的天气，则记为0。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个一维整数数组，输出是同样长度的整数数组，表示对于每天需要等待多少天。</p><blockquote><p>Input: [73, 74, 75, 71, 69, 72, 76, 73]<br>Output: [1, 1, 4, 2, 1, 1, 0, 0]</p></blockquote></li><li><p><strong>题解</strong></p><p>我们可以维持一个单调递减的栈，表示每天的温度；为了方便计算天数差，我们这里存放位置（即日期）而非温度本身。我们从左向右遍历温度数组，对于每个日期p，如果p的温度比栈顶存储位置q的温度高，则我们取出q，并记录q需要等待的天数为pq；我们重复这一过程，直到p的温度小于等于栈顶存储位置的温度（或空栈）时，我们将p插入栈顶，然后考虑下一天。在这个过程中，栈内数组永远保持单调递减，避免了使用排序进行比较。最后若栈内剩余一些日期，则说明它们之后都没有出现更暖和的日期。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; indices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!indices.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> pre_index = indices.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (temperatures[i] &lt;= temperatures[pre_index]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            indices.<span class="built_in">pop</span>();</span><br><span class="line">            ans[pre_index] = i - pre_index;</span><br><span class="line">        &#125;</span><br><span class="line">        indices.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>优先队列（priority queue）可以在 O(1) 时间内获得最大值，并且可以在 O(log n) 时间内取出最大值或插入任意值。</p><p>优先队列常常用堆（heap）来实现。堆是一个完全二叉树，其每个节点的值总是大于等于子节点的值。实际实现堆时，我们通常用一个数组而不是用指针建立一个树。这是因为堆是完全二叉树，所以用数组表示时，位置 i 的节点的父节点位置一定为 i&#x2F;2，而它的两个子节点的位置又一定分别为 2i 和 2i+1。</p><p>以下是堆的实现方法，其中最核心的两个操作是上浮和下沉：如果一个节点比父节点大，那么需要交换这个两个节点；交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，我们称之为上浮；类似地，如果一个节点比父节小，也需要不断地向下进行比较和交换操作，我们称之为下沉。如果一个节点有两个子节点，我们总是交换最大的子节点。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TB100((100))19((19))36((36))17((17))    3((3))    25((25))    1((1))    2((2))    7((7))100---19100---3619---1719---336---2536---117---217---7  </pre></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入任意值：把新的数字放在最后一位，然后上浮</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    heap.<span class="built_in">push_back</span>(k);</span><br><span class="line">    <span class="built_in">swim</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最大值：把最后一个数字挪到开头，然后下沉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">0</span>] = heap.<span class="built_in">back</span>();</span><br><span class="line">    heap.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">sink</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上浮</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (pos &gt; <span class="number">1</span> &amp;&amp; heap[pos/<span class="number">2</span>] &lt; heap[pos])) &#123;</span><br><span class="line">       <span class="built_in">swap</span>(heap[pos/<span class="number">2</span>], heap[pos]);</span><br><span class="line">        pos /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下沉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sink</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * pos &lt;= N) &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span> * pos;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; N &amp;&amp; heap[i] &lt; heap[i+<span class="number">1</span>]) ++i;</span><br><span class="line">        <span class="keyword">if</span> (heap[pos] &gt;= heap[i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[pos], heap[i]);</span><br><span class="line">        pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将算法中的大于号和小于号互换，我们也可以得到一个快速获得最小值的优先队列。</p><p>另外，正如我们在STL章节提到的那样，如果我们需要在维持大小关系的同时，还需要支持查找任意值、删除任意值、维护所有数字的大小关系等操作，可以考虑使用set或map来代替优先队列。</p><h4 id="23-Merge-k-Sorted-Lists-Hard"><a href="#23-Merge-k-Sorted-Lists-Hard" class="headerlink" title="23. Merge k Sorted Lists (Hard)"></a>23. Merge k Sorted Lists (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定k个增序的链表，试将它们合并成一条增序链表。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个一维数组，每个位置存储链表的头节点；输出是一条链表。</p><blockquote><p>Input:<br>[1-&gt;4-&gt;5,<br>1-&gt;3-&gt;4,<br>2-&gt;6]<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote></li><li><p><strong>题解</strong></p><p>本题可以有很多中解法，比如类似于归并排序进行两两合并。我们这里展示一个速度比较快的方法，即把所有的链表存储在一个优先队列中，每次提取所有链表头部节点值最小的那个节点，直到所有链表都被提取完为止。注意因为Comp函数默认是对最大堆进行比较并维持递增关系，如果我们想要获取最小的节点值，则我们需要实现一个最小堆，因此比较函数应该维持递减关系，所以operator()中返回时用大于号而不是等增关系时的小于号进行比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Comp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> l1-&gt;val &gt; l2-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Comp&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (ListNode* list: lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cur-&gt;next = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="218-The-Skyline-Problem-Hard"><a href="#218-The-Skyline-Problem-Hard" class="headerlink" title="218. The Skyline Problem (Hard)"></a>218. The Skyline Problem (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定建筑物的起止位置和高度，返回建筑物轮廓（天际线）的拐点。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维整数数组，表示每个建筑物的[左端,右端,高度]；输出是一个二维整数数组，表示每个拐点的横纵坐标。</p><blockquote><p>Input: [[2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8]]<br>Output: [[2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0]]</p></blockquote></li><li><p><strong>题解</strong></p><p>我们可以使用优先队列储存每个建筑物的高度和右端（这里使用pair，其默认比较函数是先比较第一个值，如果相等则再比较第二个值），从而获取目前会拔高天际线、且妨碍到前一个建筑物（的右端端点）的下一个建筑物。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; max_heap; <span class="comment">// &lt;高度, 右端&gt;</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, len = buildings.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> cur_x, cur_h;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len || !max_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_heap.<span class="built_in">empty</span>() || i &lt; len &amp;&amp; buildings[i][<span class="number">0</span>] &lt;= max_heap.<span class="built_in">top</span>().second) &#123;</span><br><span class="line">            cur_x = buildings[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len &amp;&amp; cur_x == buildings[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                max_heap.<span class="built_in">emplace</span>(buildings[i][<span class="number">2</span>], buildings[i][<span class="number">1</span>]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur_x = max_heap.<span class="built_in">top</span>().second;</span><br><span class="line">            <span class="keyword">while</span> (!max_heap.<span class="built_in">empty</span>() &amp;&amp; cur_x &gt;= max_heap.<span class="built_in">top</span>().second) &#123;</span><br><span class="line">                max_heap.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_h = (max_heap.<span class="built_in">empty</span>()) ? <span class="number">0</span> : max_heap.<span class="built_in">top</span>().first;</span><br><span class="line">        <span class="keyword">if</span> (ans.<span class="built_in">empty</span>() || cur_h != ans.<span class="built_in">back</span>()[<span class="number">1</span>]) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;cur_x, cur_h&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><h4 id="239-Sliding-Window-Maximum-Hard"><a href="#239-Sliding-Window-Maximum-Hard" class="headerlink" title="239. Sliding Window Maximum (Hard)"></a>239. Sliding Window Maximum (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个整数数组和一个滑动窗口大小，求在这个窗口的滑动过程中，每个时刻其包含的最大值。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个一维整数数组，和一个表示滑动窗口大小的整数；输出是一个一维整数数组，表示每个时刻时的窗口内最大值。</p><blockquote><p>Input: nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>Output: [3,3,5,5,6,7]</p></blockquote><p>在这个样例中，滑动窗口在每个位置的最大包含值取法如下：</p><blockquote><p>Window position - - - - - -  Max</p><p>[1 3 -1] -3 5 3 6 7 - - - - - -  3<br>1 [3 -1 -3] 5 3 6 7 - - - - - - 3<br>1 3 [-1 -3 5] 3 6 7 - - - - - - 5<br>1 3 -1 [-3 5 3] 6 7 - - - - - - 5<br>1 3 -1 -3 [5 3 6] 7 - - - - - - 6<br>1 3 -1 -3 5 [3 6 7] - - - - - - 7</p></blockquote></li><li><p><strong>题解</strong></p><p>我们可以利用双端队列进行操作：每当向右移动时，把窗口左端的值从队列左端剔除，把队列右边小于窗口右端的值全部剔除。这样双端队列的最左端永远是当前窗口内的最大值。另外，这道题也是单调栈的一种延申：该双端队列利用从左到右递减来维持大小关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() == i - k) &#123;</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()] &lt; nums[i]) &#123;</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表，又称散列表，使用 O(n) 空间复杂度存储数据，通过哈希函数映射位置，从而实现近似 O(1) 时间复杂度的插入、查找、删除等操作。</p><p>C++ 中的哈希集合为 unordered_set，可以查找元素是否在集合中。如果需要同时存储键和值，则需要用 unordered_map，可以用来统计频率，记录内容等等。如果元素有穷，并且范围不大，那么可以用一个固定大小的数组来存储或统计元素。例如我们需要统计一个字符串中所有字母的出现次数，则可以用一个长度为 26 的数组来进行统计，其哈希函数即为字母在字母表的位置，这样空间复杂度就可以降低为常数。</p><p>一个简单的哈希表的实现如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;list&lt;T&gt;&gt; hash_table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myhash</span><span class="params">(<span class="type">const</span> T &amp; obj)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(obj, hash_table.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// size最好是质数</span></span><br><span class="line">    <span class="built_in">HashTable</span>(<span class="type">int</span> size=<span class="number">31</span>) &#123;</span><br><span class="line">        hash_table.<span class="built_in">reserve</span>(size);</span><br><span class="line">        hash_table.<span class="built_in">resize</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">HashTable</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找哈希表是否存在该值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> T &amp; obj)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash_value = <span class="built_in">myhash</span>(obj);</span><br><span class="line">        <span class="type">const</span> list&lt;T&gt; &amp; slot = hash_table[hash_value];</span><br><span class="line">        std::list&lt;T&gt;::const_iterator it = slot.<span class="built_in">cbegin</span>();</span><br><span class="line">        <span class="keyword">for</span> (; it != slot.<span class="built_in">cend</span>() &amp;&amp; *it != obj; ++it);</span><br><span class="line">        <span class="keyword">return</span> it != slot.<span class="built_in">cend</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T &amp; obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">contains</span>(obj)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> hash_value = <span class="built_in">myhash</span>(obj);</span><br><span class="line">        std::list&lt;T&gt; &amp; slot = hash_table[hash_value];</span><br><span class="line">        slot.<span class="built_in">push_front</span>(obj);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T &amp; obj)</span> </span>&#123;</span><br><span class="line">        list&lt;T&gt; &amp; slot = hash_table[<span class="built_in">myhash</span>(obj)];</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">find</span>(slot.<span class="built_in">begin</span>(), slot.<span class="built_in">end</span>(), obj);</span><br><span class="line">        <span class="keyword">if</span> (it == slot.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slot.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的对整数实现的哈希函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; key, <span class="type">const</span> <span class="type">int</span> &amp;tableSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % tableSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要大小关系的维持，且插入查找并不过于频繁，则可以使用有序的 set&#x2F;map 来代替unordered_set&#x2F;unordered_map。</p><h4 id="1-Two-Sum-Easy"><a href="#1-Two-Sum-Easy" class="headerlink" title="1. Two Sum (Easy)"></a>1. Two Sum (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个整数数组，已知有且只有两个数的和等于给定值，求这两个数的位置。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个一维整数数组和一个目标值，输出是一个大小为 2 的一维数组，表示满足条件的两个数字的位置。</p><blockquote><p>Input: nums &#x3D; [2, 7, 11, 15], target &#x3D; 9<br>Output: [0, 1]</p></blockquote><p>在这个样例中，第 0 个位置的值 2 和第 1 个位置的值 7 的和为 9 。</p></li><li><p><strong>题解</strong></p><p>我们可以利用哈希表存储遍历过的值以及它们的位置，每次遍历到位置i的时候，查找哈希表里是否存在target - nums[i]，若存在，则说明这两个值的和为target。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 键是数字，值是该数字在数组的位置</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> num = nums[i];</span><br><span class="line">        <span class="keyword">auto</span> pos = hash.<span class="built_in">find</span>(target - num);</span><br><span class="line">        <span class="keyword">if</span> (pos == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            hash[num] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pos-&gt;second);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="128-Longest-Consecutive-Sequence-Hard"><a href="#128-Longest-Consecutive-Sequence-Hard" class="headerlink" title="128. Longest Consecutive Sequence (Hard)"></a>128. Longest Consecutive Sequence (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个整数数组，求这个数组中的数字可以组成的最长连续序列有多长。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个整数数组，输出一个整数，表示连续序列的长度。</p><blockquote><p>Input: [100, 4, 200, 1, 3, 2]<br>Output: 4</p></blockquote><p>在这个样例中，最长连续序列是[1,2,3,4]。</p></li><li><p><strong>题解</strong></p><p>我们可以把所有数字放到一个哈希表，然后不断地从哈希表中任意取一个值，并删除掉其之前之后的所有连续数字，然后更新目前的最长连续序列长度。重复这一过程，我们就可以找到所有的连续数字序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num: nums) &#123;</span><br><span class="line">        hash.<span class="built_in">insert</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!hash.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = *(hash.<span class="built_in">begin</span>());</span><br><span class="line">        hash.<span class="built_in">erase</span>(cur);</span><br><span class="line">        <span class="type">int</span> next = cur + <span class="number">1</span>, prev = cur - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (hash.<span class="built_in">count</span>(next))&#123;</span><br><span class="line">            hash.<span class="built_in">erase</span>(next++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (hash.<span class="built_in">count</span>(prev)) &#123;</span><br><span class="line">            hash.<span class="built_in">erase</span>(prev--);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, next - prev - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="149-Max-Points-on-a-Line-Hard"><a href="#149-Max-Points-on-a-Line-Hard" class="headerlink" title="149. Max Points on a Line (Hard)"></a>149. Max Points on a Line (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一些二维坐标中的点，求同一条线上最多由多少点。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维整数数组，表示每个点的横纵坐标；输出是一个整数，表示满足条件的最多点数。</p><blockquote><p>Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</p><p>Output: 4</p></blockquote><p>这个样例中，y &#x3D; 5 − x 上有四个点。</p></li><li><p><strong>题解</strong></p><p>对于每个点，我们对其它点建立哈希表，统计同一斜率的点一共有多少个。这里利用的原理是，一条线可以由一个点和斜率而唯一确定。另外也要考虑斜率不存在和重复坐标的情况。</p><p>本题也利用了一个小技巧：在遍历每个点时，对于数组中位置i的点，我们只需要考虑i之后的点即可，因为i之前的点已经考虑过i了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">double</span>, <span class="type">int</span>&gt; hash; <span class="comment">// &lt;斜率, 点个数&gt;</span></span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>, same = <span class="number">1</span>, same_y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        same = <span class="number">1</span>, same_y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; points.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">1</span>] == points[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                ++same_y;</span><br><span class="line">                <span class="keyword">if</span> (points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>]) &#123;</span><br><span class="line">                    ++same;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">double</span> dx = points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>], dy = points[i][<span class="number">1</span>] -</span><br><span class="line">                    points[j][<span class="number">1</span>];</span><br><span class="line">                ++hash[dx/dy];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max_count = <span class="built_in">max</span>(max_count, same_y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> item : hash) &#123;</span><br><span class="line">            max_count = <span class="built_in">max</span>(max_count, same + item.second);</span><br><span class="line">        &#125;</span><br><span class="line">        hash.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多重集合和映射"><a href="#多重集合和映射" class="headerlink" title="多重集合和映射"></a>多重集合和映射</h3><h4 id="332-Reconstruct-Itinerary-Medium"><a href="#332-Reconstruct-Itinerary-Medium" class="headerlink" title="332. Reconstruct Itinerary (Medium)"></a>332. Reconstruct Itinerary (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个人坐过的一些飞机的起止机场，已知这个人从JFK起飞，那么这个人是按什么顺序飞的；如果存在多种可能性，返回字母序最小的那种。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维字符串数组，表示多个起止机场对子；输出是一个一维字符串数组，表示飞行顺序。</p><blockquote><p>Input: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]<br>Output: [“JFK”, “MUC”, “LHR”, “SFO”, “SJC”]</p></blockquote></li><li><p><strong>题解</strong></p><p>本题可以先用哈希表记录起止机场，其中键是起始机场，值是一个多重集合，表示对应的终止机场。因为一个人可能坐过重复的线路，所以我们需要使用多重集合储存重复值。储存完成之后，我们可以利用栈来恢复从终点到起点飞行的顺序，再将结果逆序得到从起点到终点的顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (tickets.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string, multiset&lt;string&gt;&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; ticket: tickets) &#123;</span><br><span class="line">        hash[ticket[<span class="number">0</span>]].<span class="built_in">insert</span>(ticket[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;string&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        string next = s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (hash[next].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(next);</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(*hash[next].<span class="built_in">begin</span>());</span><br><span class="line">            hash[next].<span class="built_in">erase</span>(hash[next].<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="前缀和与积分图"><a href="#前缀和与积分图" class="headerlink" title="前缀和与积分图"></a>前缀和与积分图</h3><p>一维的前缀和，二维的积分图，都是把每个位置之前的一维线段或二维矩形预先存储，方便加速计算。如果需要对前缀和或积分图的值做寻址，则要存在哈希表里；如果要对每个位置记录前缀和或积分图的值，则可以储存到一维或二维数组里，也常常伴随着动态规划。</p><h4 id="303-Range-Sum-Query-Immutable-Easy"><a href="#303-Range-Sum-Query-Immutable-Easy" class="headerlink" title="303. Range Sum Query - Immutable (Easy)"></a>303. Range Sum Query - Immutable (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>设计一个数据结构，使得其能够快速查询给定数组中，任意两个位置间所有数字的和。</p></li><li><p><strong>输入输出样例</strong></p><p>以下是数据结构的调用样例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">-2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">-5</span>,<span class="number">2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">NumArray num_array =<span class="built_in">newNumArray</span>(nums);</span><br><span class="line">num_array.<span class="built_in">sumRange</span>(<span class="number">0</span>,<span class="number">2</span>);<span class="comment">// Result= -2+0+3= 1.</span></span><br><span class="line">num_array.<span class="built_in">sunRange</span>(<span class="number">1</span>,<span class="number">5</span>);<span class="comment">// Result= 0+3-5+2-1= -1.</span></span><br></pre></td></tr></table></figure></li><li><p><strong>题解</strong></p><p>对于一维的数组，我们可以使用前缀和来解决此类问题。先建立一个与数组nums长度相同的新数组psum，表示nums每个位置之前前所有数字的和。psum数组可以通过C++自带的partial_sum函数建立，也可以直接遍历一遍nums数组，并利用状态转移方程psum[i] &#x3D; psum[i-1] + nums[i]完成统计。如果我们需要获得位置i和j之间的数字和，只需计算psum[j+1] - psum[i]即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; psum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt; nums): <span class="built_in">psum</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">partial_sum</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), psum.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> psum[j+<span class="number">1</span>] - psum[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="304-Range-Sum-Query-2D-Immutable-Medium"><a href="#304-Range-Sum-Query-2D-Immutable-Medium" class="headerlink" title="304. Range Sum Query 2D - Immutable (Medium)"></a>304. Range Sum Query 2D - Immutable (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>设计一个数据结构，使得其能够快速查询给定矩阵中，任意两个位置包围的长方形中所有数字的和。</p></li><li><p><strong>输入输出样例</strong></p><p>以下是数据结构的调用样例。其中sumRegion函数的四个输入分别是第一个点的横、纵坐标，和第二个点的横、纵坐标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; matrix&#123;&#123;<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">NumMatrix num_matrix = <span class="built_in">newNumMatrix</span>(matrix);</span><br><span class="line">num_matrix.<span class="built_in">sumRegion</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>);<span class="comment">// Result =8.</span></span><br><span class="line">num_matrix.<span class="built_in">sumRegion</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);<span class="comment">// Result =11.</span></span><br></pre></td></tr></table></figure></li><li><p><strong>题解</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; integral;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix) &#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = m &gt; <span class="number">0</span>? matrix[<span class="number">0</span>].<span class="built_in">size</span>(): <span class="number">0</span>;</span><br><span class="line">        integral = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                integral[i][j] = matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] + integral[i<span class="number">-1</span>][j] +integral[i][j<span class="number">-1</span>] - integral[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> integral[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - integral[row2+<span class="number">1</span>][col1] -</span><br><span class="line">            integral[row1][col2+<span class="number">1</span>] + integral[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="560-Subarray-Sum-Equals-K-Medium"><a href="#560-Subarray-Sum-Equals-K-Medium" class="headerlink" title="560. Subarray Sum Equals K (Medium)"></a>560. Subarray Sum Equals K (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个数组，寻找和为k的连续区间个数。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个一维整数数组和一个整数值k；输出一个整数，表示满足条件的连续区间个数。</p><blockquote><p>Input: nums &#x3D; [1,1,1], k &#x3D; 2<br>Output: 2</p></blockquote><p>在这个样例中，我们可以找到两个[1,1]连续区间满足条件。</p></li><li><p><strong>题解</strong></p><p>本题同样是利用前缀和，不同的是这里我们使用一个哈希表hashmap，其键是前缀和，而值是该前缀和出现的次数。在我们遍历到位置i时，假设当前的前缀和是psum，那么hashmap[psum-k]即为以当前位置结尾、满足条件的区间个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, psum = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashmap;</span><br><span class="line">    hashmap[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化很重要</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums) &#123;</span><br><span class="line">        psum += i;</span><br><span class="line">        count += hashmap[psum-k];</span><br><span class="line">        ++hashmap[psum];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-9"><a href="#练习-9" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/reshape-the-matrix/">566. Reshape the Matrix (Easy)</a></p><p><a href="https://leetcode.com/problems/implement-stack-using-queues/">225. Implement Stack using Queues (Easy)</a></p><p><a href="https://leetcode.com/problems/next-greater-element-ii/">503. Next Greater Element II (Medium)</a></p><p><a href="https://leetcode.com/problems/contains-duplicate/">217. Contains Duplicate (Easy)</a></p><p><a href="https://leetcode.com/problems/degree-of-an-array/">697. Degree of an Array (Easy)</a></p><p><a href="https://leetcode.com/problems/longest-harmonious-subsequence/">594. Longest Harmonious Subsequence (Easy)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/find-the-duplicate-number/">287. Find the Duplicate Number (Medium)</a></p><p><a href="https://leetcode.com/problems/super-ugly-number/">313. Super Ugly Number (Medium)</a></p><p><a href="https://leetcode.com/problems/advantage-shuffle/">870. Advantage Shuffle (Medium)</a></p><p><a href="https://leetcode.com/problems/range-sum-query-mutable/">307. Range Sum Query - Mutable (Medium)</a></p></li></ul><h2 id="第-12-章-令人头大的字符串"><a href="#第-12-章-令人头大的字符串" class="headerlink" title="第 12 章 令人头大的字符串"></a>第 12 章 令人头大的字符串</h2><h3 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h3><p>字符串可以看成是字符组成的数组。由于字符串是程序里经常需要处理的数据类型，因此有很多针对字符串处理的题目，以下是一些常见的类型。</p><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><h4 id="242-Valid-Anagram-Easy"><a href="#242-Valid-Anagram-Easy" class="headerlink" title="242. Valid Anagram (Easy)"></a>242. Valid Anagram (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>判断两个字符串包含的字符是否完全相同。</p></li><li><p><strong>输入输出样例</strong></p><p>输入两个字符串，输出一个布尔值，表示两个字符串是否满足条件。</p><blockquote><p>Input: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>Output: true</p></blockquote></li><li><p><strong>题解</strong></p><p>我们可以利用哈希表或者数组统计两个数组中每个数字出现的频次，若频次相同，则说明它们包含的字符完全相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counts</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        ++counts[s[i]-’a’];</span><br><span class="line">        --counts[t[i]-’a’];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="205-Isomorphic-Strings-Easy"><a href="#205-Isomorphic-Strings-Easy" class="headerlink" title="205. Isomorphic Strings (Easy)"></a>205. Isomorphic Strings (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>判断两个字符串是否同构。同构的定义是，可以通过把一个字符串的某些相同的字符转换成另一些相同的字符，使得两个字符串相同，且两种不同的字符不能够被转换成同一种字符。</p></li><li><p><strong>输入输出样例</strong></p><p>输入两个字符串，输出一个布尔值，表示两个字符串是否满足条件。</p><blockquote><p>Input: s &#x3D; “paper”, t &#x3D; “title”<br>Output: true</p></blockquote><p>在这个样例中，通过把s中的p、a、e、r字符转换成t、i、l、e字符，可以使得两个字符串相同，</p></li><li><p><strong>题解</strong></p><p>我们可以将问题转化一下：记录两个字符串每个位置的字符第一次出现的位置，如果两个字符串中相同位置的字符与它们第一次出现的位置一样，那么这两个字符串同构。举例来说，对于“paper”和“title”，假设我们现在遍历到第三个字符“p”和“t”，发现它们第一次出现的位置都在第一个字符，则说明目前位置满足同构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s_first_index</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span>, <span class="title">t_first_index</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_first_index[s[i]] != t_first_index[t[i]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s_first_index[s[i]] = t_first_index[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="647-Palindromic-Substrings-Medium"><a href="#647-Palindromic-Substrings-Medium" class="headerlink" title="647. Palindromic Substrings (Medium)"></a>647. Palindromic Substrings (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个字符，求其有多少个回文子字符串。回文的定义是左右对称。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个字符串，输出一个整数，表示回文子字符串的数量。</p><blockquote><p>Input: “aaa”<br>Output: 6</p></blockquote><p>六个回文子字符串分别是[“a”,”a”,”a”,”aa”,”aa”,”aaa”]。</p></li><li><p><strong>题解</strong></p><p>我们可以从字符串的每个位置开始，向左向右延长，判断存在多少以当前位置为中轴的回文子字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        count += <span class="built_in">extendSubstrings</span>(s, i, i); <span class="comment">// 奇数长度</span></span><br><span class="line">        count += <span class="built_in">extendSubstrings</span>(s, i, i + <span class="number">1</span>); <span class="comment">// 偶数长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extendSubstrings</span><span class="params">(string s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">length</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">        --l;</span><br><span class="line">        ++r;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="696-Count-Binary-Substrings-Easy"><a href="#696-Count-Binary-Substrings-Easy" class="headerlink" title="696. Count Binary Substrings (Easy)"></a>696. Count Binary Substrings (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个0-1字符串，求有多少非空子字符串的 0 和 1 数量相同。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个字符串，输出一个整数，表示满足条件的子字符串的数量。</p><blockquote><p>Input: “00110011”<br>Output: 6</p></blockquote><p>在这个样例中，六个 0 和 1 数量相同的子字符串是[“0011”,”01”,”1100”,”10”,”0011”,”01”]。</p></li><li><p><strong>题解</strong></p><p>从左往右遍历数组，记录和当前位置数字相同且连续的长度，以及其之前连续的不同数字的长度。举例来说，对于 00110 的最后一位，我们记录的相同数字长度是 1 ，因为只有一个连续 0 ；我们记录的不同数字长度是 2 ，因为在 0 之前有两个连续的 1 。若不同数字的连续长度大于等于当前数字的连续长度，则说明存在一个且只存在一个以当前数字结尾的满足条件的子字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countBinarySubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (s[i] == s[i<span class="number">-1</span>]) &#123;</span><br><span class="line">           ++cur;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre &gt;= cur) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串理解"><a href="#字符串理解" class="headerlink" title="字符串理解"></a>字符串理解</h3><h4 id="227-Basic-Calculator-II-Medium"><a href="#227-Basic-Calculator-II-Medium" class="headerlink" title="227. Basic Calculator II (Medium)"></a>227. Basic Calculator II (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个包含加减乘除整数运算的字符串，求其运算结果，只保留整数。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个合法的运算字符串，输出是一个整数，表示其运算结果。</p><blockquote><p>Input: “ 3+5 &#x2F; 2 “<br>Output: 5</p></blockquote><p>在这个样例中，因为除法的优先度高于加法，所以结果是 5 而非 4 </p></li><li><p><strong>题解</strong></p><p>如果我们在字符串左边加上一个加号，可以证明其并不改变运算结果，且字符串可以分割成多个&lt;一个运算符，一个数字&gt;对子的形式；这样一来我们就可以从左往右处理了。由于乘除的优先级高于加减，因此我们需要使用一个中间变量来存储高优先度的运算结果。</p><p>此类型题也考察很多细节处理，如无运算符的情况，和多个空格的情况等等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseExpr</span>(s, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数 - 递归parse从位置i开始的剩余字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parseExpr</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> op = ’+’;</span><br><span class="line">    <span class="type">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != ’ ’) &#123;</span><br><span class="line">            <span class="type">long</span> n = <span class="built_in">parseNum</span>(s, i);</span><br><span class="line">            <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                <span class="keyword">case</span> ’+’ : left += right; right = n; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ’-’ : left += right; right = -n; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ’*’ : right *= n; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ’/’ : right /= n; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">                op = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数 - parse从位置i开始的一个数字</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">parseNum</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">length</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">        n = <span class="number">10</span> * n + (s[i++] - ’<span class="number">0</span>’);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><h4 id="28-Implement-strStr-Easy"><a href="#28-Implement-strStr-Easy" class="headerlink" title="28. Implement strStr() (Easy)"></a>28. Implement strStr() (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>判断一个字符串是不是另一个字符串的子字符串，并返回其位置。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个母字符串和一个子字符串，输出一个整数，表示子字符串在母字符串的位置，若不存在则返回-1。</p><blockquote><p>Input: haystack &#x3D; “hello”, needle &#x3D; “ll”<br>Output: 2</p></blockquote></li><li><p><strong>题解</strong></p><p>使用著名的Knuth-Morris-Pratt（KMP）算法，可以在O¹m+nº时间利用动态规划完成匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>, n = haystack.<span class="built_in">length</span>(), p = needle.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(p, <span class="number">-1</span>)</span></span>; <span class="comment">// -1表示不存在相同的最大前缀和后缀</span></span><br><span class="line">    <span class="built_in">calNext</span>(needle, next); <span class="comment">// 计算next数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">-1</span> &amp;&amp; needle[k+<span class="number">1</span>] != haystack[i]) &#123;</span><br><span class="line">            k = next[k]; <span class="comment">// 有部分匹配，往前回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[k+<span class="number">1</span>] == haystack[i]) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == p<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - p + <span class="number">1</span>; <span class="comment">// 说明k移动到needle的最末端，返回相应的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数 - 计算next数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calNext</span><span class="params">(<span class="type">const</span> string &amp;needle, vector&lt;<span class="type">int</span>&gt; &amp;next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, p = <span class="number">-1</span>; j &lt; needle.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; <span class="number">-1</span> &amp;&amp; needle[p+<span class="number">1</span>] != needle[j]) &#123;</span><br><span class="line">            p = next[p]; <span class="comment">// 如果下一位不同，往前回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[p+<span class="number">1</span>] == needle[j]) &#123;</span><br><span class="line">            ++p; <span class="comment">// 如果下一位相同，更新相同的最大前缀和最大后缀长</span></span><br><span class="line">        &#125;</span><br><span class="line">        next[j] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-10"><a href="#练习-10" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/longest-palindrome/">409. Longest Palindrome (Easy)</a></p><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters (Medium)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/basic-calculator-iii/">772. Basic Calculator III (Hard)</a></p><p><a href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring (Medium)</a></p></li></ul><h2 id="第-13-章-指针三剑客之一：链表"><a href="#第-13-章-指针三剑客之一：链表" class="headerlink" title="第 13 章 指针三剑客之一：链表"></a>第 13 章 指针三剑客之一：链表</h2><h3 id="数据结构介绍"><a href="#数据结构介绍" class="headerlink" title="数据结构介绍"></a>数据结构介绍</h3><p>（单）链表是由节点和指针构成的数据结构，每个节点存有一个值，和一个指向下一个节点的指针，因此很多链表问题可以用递归来处理。不同于数组，链表并不能直接获取任意节点的值，必须要通过指针找到该节点后才能获取其值。同理，在未遍历到链表结尾时，我们也无法知道链表的长度，除非依赖其他数据结构储存长度。LeetCode默认的链表表示方法如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    intval;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(intx) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于在进行链表操作时，尤其是删除节点时，经常会因为对当前节点进行操作而导致内存或指针出现问题。有两个小技巧可以解决这个问题：一是尽量处理当前节点的下一个节点而非当前节点本身，二是建立一个虚拟节点(dummy node)，使其指向当前链表的头节点，这样即使原链表所有节点全被删除，也会有一个dummy存在，返回dummy-&gt;next即可。</p><p><font color=#FF0000 >注意</font> <font face="楷体" >一般来说，算法题不需要删除内存。在刷LeetCode的时候，如果想要删除一个节点，可以直接进行指针操作而无需回收内存。实际做软件工程时，对于无用的内存，笔者建议尽量显式回收，或利用智能指针。</font></p><h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><h4 id="206-Reverse-Linked-List-Easy"><a href="#206-Reverse-Linked-List-Easy" class="headerlink" title="206. Reverse Linked List (Easy)"></a>206. Reverse Linked List (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>翻转一个链表。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个链表，输出该链表翻转后的结果。</p><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;nullptr<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;nullptr</p></blockquote></li><li><p><strong>题解</strong></p><p>链表翻转是非常基础也一定要掌握的技能。我们提供了两种写法——递归和非递归，且我们建议你同时掌握这两种写法。</p><p>递归的写法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head, ListNode* prev=<span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* next = head-&gt;next;</span><br><span class="line">    head-&gt;next = prev;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reverseList</span>(next, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归的写法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *prev = <span class="literal">nullptr</span>, *next;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        head-&gt;next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="21-Merge-Two-Sorted-Lists-Easy"><a href="#21-Merge-Two-Sorted-Lists-Easy" class="headerlink" title="21. Merge Two Sorted Lists (Easy)"></a>21. Merge Two Sorted Lists (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定两个增序的链表，试将其合并成一个增序的链表。</p></li><li><p><strong>输入输出样例</strong></p><p>输入两个链表，输出一个链表，表示两个链表合并的结果。</p><blockquote><p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote></li><li><p><strong>题解</strong></p><p>我们提供了递归和非递归，共两种写法。递归的写法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l2) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!l1) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class="line">        l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归的写法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *node = dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">            node-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;next = l1? l1: l2;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="24-Swap-Nodes-in-Pairs-Medium"><a href="#24-Swap-Nodes-in-Pairs-Medium" class="headerlink" title="24. Swap Nodes in Pairs (Medium)"></a>24. Swap Nodes in Pairs (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个矩阵，交换每个相邻的一对节点。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个链表，输出该链表交换后的结果。</p><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;4<br>Output: 2-&gt;1-&gt;4-&gt;3</p></blockquote></li><li><p><strong>题解</strong></p><p>利用指针进行交换操作，没有太大难度，但一定要细心。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *p = head, *s;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">        s = p-&gt;next;</span><br><span class="line">        p-&gt;next = s-&gt;next;</span><br><span class="line">        s-&gt;next = p;</span><br><span class="line">        head = s;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">            s = p-&gt;next-&gt;next;</span><br><span class="line">            p-&gt;next-&gt;next = s-&gt;next;</span><br><span class="line">            s-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = s;</span><br><span class="line">            p = s-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="其它链表技巧"><a href="#其它链表技巧" class="headerlink" title="其它链表技巧"></a>其它链表技巧</h3><h4 id="160-Intersection-of-Two-Linked-Lists-Easy"><a href="#160-Intersection-of-Two-Linked-Lists-Easy" class="headerlink" title="160. Intersection of Two Linked Lists (Easy)"></a>160. Intersection of Two Linked Lists (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定两个链表，判断它们是否相交于一点，并求这个相交节点。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是两条链表，输出是一个节点。如无相交节点，则返回一个空节点。</p></li><li><p><strong>题解</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *l1 = headA, *l2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">        l1 = l1? l1-&gt;next: headB;</span><br><span class="line">        l2 = l2? l2-&gt;next: headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="234-Palindrome-Linked-List-Easy"><a href="#234-Palindrome-Linked-List-Easy" class="headerlink" title="234. Palindrome Linked List (Easy)"></a>234. Palindrome Linked List (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>以 O(1) 的空间复杂度，判断链表是否回文。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个链表，输出是一个布尔值，表示链表是否回文。</p><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;2-&gt;1<br>Output: true</p></blockquote></li><li><p><strong>题解</strong></p><p>先使用快慢指针找到链表中点，再把链表切成两半；然后把后半段翻转；最后比较两半是否相等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next = <span class="built_in">reverseList</span>(slow-&gt;next);</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val != slow-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *prev = <span class="literal">nullptr</span>, *next;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        head-&gt;next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-11"><a href="#练习-11" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">83. Remove Duplicates from Sorted List (Easy)</a></p><p><a href="https://leetcode.com/problems/odd-even-linked-list/">328. Odd Even Linked List (Medium)</a></p><p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List (Medium)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/sort-list/">148. Sort List (Medium)</a></p></li></ul><h2 id="第-14-章-指针三剑客之二：树"><a href="#第-14-章-指针三剑客之二：树" class="headerlink" title="第 14 章 指针三剑客之二：树"></a>第 14 章 指针三剑客之二：树</h2><h3 id="数据结构介绍-1"><a href="#数据结构介绍-1" class="headerlink" title="数据结构介绍"></a>数据结构介绍</h3><p>作为（单）链表的升级版，我们通常接触的树都是二叉树（binary tree），即每个节点最多有两个子节点；且除非题目说明，默认树中不存在循环结构。LeetCode默认的树表示方法如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，其与链表的主要差别就是多了一个子节点的指针。</p><h3 id="树的递归"><a href="#树的递归" class="headerlink" title="树的递归"></a>树的递归</h3><p>对于一些简单的递归题，某些LeetCode达人喜欢写one-line code，即用一行代码解决问题，把if-else判断语句压缩成问号冒号的形式。我们也会展示一些这样的代码，但是对于新手，笔者仍然建议您使用if-else判断语句。</p><p>在很多时候，树递归的写法与深度优先搜索的递归写法相同，因此本书不会区分二者。</p><h4 id="104-Maximum-Depth-of-Binary-Tree-Easy"><a href="#104-Maximum-Depth-of-Binary-Tree-Easy" class="headerlink" title="104. Maximum Depth of Binary Tree (Easy)"></a>104. Maximum Depth of Binary Tree (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>求一个二叉树的最大深度。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二叉树，输出是一个整数，表示该树的最大深度。</p></li><li><p><strong>题解</strong></p><p>利用递归，我们可以很方便地求得最大深度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root? <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)): <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="110-Balanced-Binary-Tree-Easy"><a href="#110-Balanced-Binary-Tree-Easy" class="headerlink" title="110. Balanced Binary Tree (Easy)"></a>110. Balanced Binary Tree (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>判断一个二叉树是否平衡。树平衡的定义是，对于树上的任意节点，其两侧节点的最大深度的差值不得大于 1 。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二叉树，输出一个布尔值，表示树是否平衡。</p></li><li><p><strong>题解</strong></p><p>解法类似于求树的最大深度，但有两个不同的地方：一是我们需要先处理子树的深度再进行比较，二是如果我们在处理子树时发现其已经不平衡了，则可以返回一个-1，使得所有其长辈节点可以避免多余的判断（本题的判断比较简单，做差后取绝对值即可；但如果此处是一个开销较大的比较过程，则避免重复判断可以节省大量的计算时间）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(root) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">helper</span>(root-&gt;left), right = <span class="built_in">helper</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">-1</span> || right == <span class="number">-1</span> || <span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="543-Diameter-of-Binary-Tree-Easy"><a href="#543-Diameter-of-Binary-Tree-Easy" class="headerlink" title="543. Diameter of Binary Tree (Easy)"></a>543. Diameter of Binary Tree (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>求一个二叉树的最长直径。直径的定义是二叉树上任意两节点之间的无向距离。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二叉树，输出一个整数，表示最长直径。</p></li><li><p><strong>题解</strong></p><p>同样的，我们可以利用递归来处理树。解题时要注意，在我们处理某个子树时，我们更新的最长直径值和递归返回的值是不同的。这是因为待更新的最长直径值是经过该子树根节点的最长直径（即两侧长度）；而函数返回值是以该子树根节点为端点的最长直径值（即一侧长度），使用这样的返回值才可以通过递归更新父节点的最长直径值）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> diameter = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">helper</span>(root, diameter);</span><br><span class="line">    <span class="keyword">return</span> diameter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="type">int</span>&amp; diameter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">helper</span>(node-&gt;left, diameter), r = <span class="built_in">helper</span>(node-&gt;right, diameter);</span><br><span class="line">    diameter = <span class="built_in">max</span>(l + r, diameter);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="437-Path-Sum-III-Easy"><a href="#437-Path-Sum-III-Easy" class="headerlink" title="437. Path Sum III (Easy)"></a>437. Path Sum III (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个整数二叉树，求有多少条路径节点值的和等于给定值。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个二叉树和一个给定整数，输出一个整数，表示有多少条满足条件的路径。</p></li><li><p><strong>题解</strong></p><p>递归每个节点时，需要分情况考虑：(1)如果选取该节点加入路径，则之后必须继续加入连续节点，或停止加入节点(2)如果不选取该节点加入路径，则对其左右节点进行重新进行考虑。因此一个方便的方法是我们创建一个辅函数，专门用来计算连续加入节点的路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root? <span class="built_in">pathSumStartWithRoot</span>(root, sum) +</span><br><span class="line">        <span class="built_in">pathSum</span>(root-&gt;left, sum) + <span class="built_in">pathSum</span>(root-&gt;right, sum): <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathSumStartWithRoot</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = root-&gt;val == sum? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">pathSumStartWithRoot</span>(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    count += <span class="built_in">pathSumStartWithRoot</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="101-Symmetric-Tree-Easy"><a href="#101-Symmetric-Tree-Easy" class="headerlink" title="101. Symmetric Tree (Easy)"></a>101. Symmetric Tree (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>判断一个二叉树是否对称。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个二叉树，输出一个布尔值，表示该树是否对称。</p></li><li><p><strong>题解</strong></p><p>判断一个树是否对称等价于判断左右子树是否对称。笔者一般习惯将判断两个子树是否相等或对称类型的题的解法叫做“四步法”：(1)如果两个子树都为空指针，则它们相等或对称(2)如果两个子树只有一个为空指针，则它们不相等或不对称(3)如果两个子树根节点的值不相等，则它们不相等或不对称(4)根据相等或对称要求，进行递归处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root? <span class="built_in">isSymmetric</span>(root-&gt;left, root-&gt;right): <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!left || !right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left-&gt;val != right-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSymmetric</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">isSymmetric</span>(left-&gt;right,right-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1110-Delete-Nodes-And-Return-Forest-Medium"><a href="#1110-Delete-Nodes-And-Return-Forest-Medium" class="headerlink" title="1110. Delete Nodes And Return Forest (Medium)"></a>1110. Delete Nodes And Return Forest (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个整数二叉树和一些整数，求删掉这些整数对应的节点后，剩余的子树。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个整数二叉树和一个一维整数数组，输出一个数组，每个位置存储一个子树（的根节点）。</p></li><li><p><strong>题解</strong></p><p>这道题最主要需要注意的细节是如果通过递归处理原树，以及需要在什么时候断开指针。同时，为了便于寻找待删除节点，可以建立一个哈希表方便查找。笔者强烈建议读者在看完题解后，自己写一遍本题，加深对于递归的理解和运用能力。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; forest;</span><br><span class="line">    <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">dict</span><span class="params">(to_delete.begin(), to_delete.end())</span></span>;</span><br><span class="line">    root = <span class="built_in">helper</span>(root, dict, forest);</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        forest.<span class="built_in">push_back</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> forest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* root, unordered_set&lt;<span class="type">int</span>&gt; &amp; dict, vector&lt;TreeNode*&gt; &amp;forest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left = <span class="built_in">helper</span>(root-&gt;left, dict, forest);</span><br><span class="line">    root-&gt;right = <span class="built_in">helper</span>(root-&gt;right, dict, forest);</span><br><span class="line">    <span class="keyword">if</span> (dict.<span class="built_in">count</span>(root-&gt;val)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            forest.<span class="built_in">push_back</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            forest.<span class="built_in">push_back</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>我们可以使用广度优先搜索进行层次遍历。注意，不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p><h4 id="637-Average-of-Levels-in-Binary-Tree-Easy"><a href="#637-Average-of-Levels-in-Binary-Tree-Easy" class="headerlink" title="637. Average of Levels in Binary Tree (Easy)"></a>637. Average of Levels in Binary Tree (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个二叉树，求每一层的节点值的平均数。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二叉树，输出是一个一维数组，表示每层节点值的平均数。</p></li><li><p><strong>题解</strong></p><p>利用广度优先搜索，我们可以很方便地求取每层的平均值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> count = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            sum += node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(sum / count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h3><p>前序遍历、中序遍历和后序遍历是三种利用深度优先搜索遍历二叉树的方式。它们是在对节点访问的顺序有一点不同，其它完全相同。考虑如下一棵树，</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TB1((1))2((2))3((3))4((4))5((5))6((6))1---21---32---42---53---0(( ))style 0 fill:#f100,stroke-width:0pxlinkStyle 4 stroke:#0ff,stroke-width:0px3---6  </pre></div><p>前序遍历先遍历父结点，再遍历左结点，最后遍历右节点，我们得到的遍历顺序是 [1 2 4 5 3 6]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(root);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历先遍历左节点，再遍历父结点，最后遍历右节点，我们得到的遍历顺序是 [4 2 5 1 3 6]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">visit</span>(root);</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历先遍历左节点，再遍历右结点，最后遍历父节点，我们得到的遍历顺序是 [4 5 2 6 3 1]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">visit</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)"></a>105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个二叉树的前序遍历和中序遍历结果，尝试复原这个树。已知树里不存在重复值的节点。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是两个一维数组，分别表示树的前序遍历和中序遍历结果；输出是一个二叉树。</p></li><li><p><strong>题解</strong></p><p>我们通过本题的样例讲解一下本题的思路。前序遍历的第一个节点是 4 ，意味着 4 是根节点。我们在中序遍历结果里找到 4 这个节点，根据中序遍历的性质可以得出， 4 在中序遍历数组位置的左子数组为左子树，节点数为 1 ，对应的是前序排列数组里 4 之后的 1 个数字（ 9 ）； 4 在中序遍历数组位置的右子数组为右子树，节点数为 3 ，对应的是前序排列数组里最后的 3 个数字。有了这些信息，我们就可以对左子树和右子树进行递归复原了。为了方便查找数字的位置，我们可以用哈希表预处理中序遍历的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; preorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        hash[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">buildTreeHelper</span>(hash, preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTreeHelper</span><span class="params">(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp; hash, vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">int</span> s0, <span class="type">int</span> e0, <span class="type">int</span> s1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s0 &gt; e0) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = preorder[s1], index = hash[mid], leftLen = index - s0 - <span class="number">1</span>;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid);</span><br><span class="line">    node-&gt;left = <span class="built_in">buildTreeHelper</span>(hash, preorder, s0, index - <span class="number">1</span>, s1 + <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = <span class="built_in">buildTreeHelper</span>(hash, preorder, index + <span class="number">1</span>, e0, s1 + <span class="number">2</span> + leftLen);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="144-Binary-Tree-Preorder-Traversal-Medium"><a href="#144-Binary-Tree-Preorder-Traversal-Medium" class="headerlink" title="144. Binary Tree Preorder Traversal (Medium)"></a>144. Binary Tree Preorder Traversal (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>不使用递归，实现二叉树的前序遍历。</p></li><li><p><strong>输入输出样例</strong></p><p>输入一个二叉树，输出一个数组，为二叉树前序遍历的结果，</p></li><li><p><strong>题解</strong></p><p>因为递归的本质是栈调用，因此我们可以通过栈来实现前序遍历。注意入栈的顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ret.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 先右后左，保证左子树先遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树（Binary Search Tree, BST）是一种特殊的二叉树：对于每个父节点，其左子节点的值小于等于父结点的值，其右子节点的值大于等于父结点的值。因此对于一个二叉查找树，我们可以在 O(n log n) 的时间内查找一个值是否存在：从根节点开始，若当前节点的值大于查找值则向左下走，若当前节点的值小于查找值则向右下走。同时因为二叉查找树是有序的，对其中序遍历的结果即为排好序的数组。</p><p>一个二叉查找树的实现如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        T data;</span><br><span class="line">        Node* left;</span><br><span class="line">        Node* right;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="function">Node* <span class="title">makeEmpty</span><span class="params">(Node* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">makeEmpty</span>(t-&gt;left);</span><br><span class="line">        <span class="built_in">makeEmpty</span>(t-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* t, T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> Node;</span><br><span class="line">            t-&gt;data = x;</span><br><span class="line">            t-&gt;left = t-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; t-&gt;data) &#123;</span><br><span class="line">            t-&gt;left = <span class="built_in">insert</span>(t-&gt;left, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; t-&gt;data) &#123;</span><br><span class="line">            t-&gt;right = <span class="built_in">insert</span>(t-&gt;right, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">find</span><span class="params">(Node* t, T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; t-&gt;data) <span class="keyword">return</span> <span class="built_in">find</span>(t-&gt;left, x);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; t-&gt;data) <span class="keyword">return</span> <span class="built_in">find</span>(t-&gt;right, x);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">findMin</span><span class="params">(Node* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span> || t-&gt;left == <span class="literal">NULL</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findMin</span>(t-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">findMax</span><span class="params">(Node* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span> || t-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findMax</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">remove</span><span class="params">(Node* t, T x)</span> </span>&#123;</span><br><span class="line">        Node* temp;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; t-&gt;data) t-&gt;left = <span class="built_in">remove</span>(t-&gt;left, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; t-&gt;data) t-&gt;right = <span class="built_in">remove</span>(t-&gt;right, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;left &amp;&amp; t-&gt;right) &#123;</span><br><span class="line">            temp = <span class="built_in">findMin</span>(t-&gt;right);</span><br><span class="line">            t-&gt;data = temp-&gt;data;</span><br><span class="line">            t-&gt;right = <span class="built_in">remove</span>(t-&gt;right, t-&gt;data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = t;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span>) t = t-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;right == <span class="literal">NULL</span>) t = t-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BST</span>(): <span class="built_in">root</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">BST</span>() &#123;</span><br><span class="line">        root = <span class="built_in">makeEmpty</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(root, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">remove</span>(root, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="99-Recover-Binary-Search-Tree-Hard"><a href="#99-Recover-Binary-Search-Tree-Hard" class="headerlink" title="99. Recover Binary Search Tree (Hard)"></a>99. Recover Binary Search Tree (Hard)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个二叉查找树，已知有两个节点被不小心交换了，试复原此树。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个被误交换两个节点的二叉查找树，输出是改正后的二叉查找树。</p></li><li><p><strong>题解</strong></p><p>我们可以使用中序遍历这个二叉查找树，同时设置一个prev指针，记录当前节点中序遍历时的前节点。如果当前节点大于prev节点的值，说明需要调整次序。有一个技巧是如果遍历整个序列过程中只出现了一次次序错误，说明就是这两个相邻节点需要被交换；如果出现了两次次序错误，那就需要交换这两个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    TreeNode *mistake1 = <span class="literal">nullptr</span>, *mistake2 = <span class="literal">nullptr</span>, *prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root, mistake1, mistake2, prev);</span><br><span class="line">    <span class="keyword">if</span> (mistake1 &amp;&amp; mistake2) &#123;</span><br><span class="line">        <span class="type">int</span> temp = mistake1-&gt;val;</span><br><span class="line">        mistake1-&gt;val = mistake2-&gt;val;</span><br><span class="line">        mistake2-&gt;val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, TreeNode*&amp; mistake1, TreeNode*&amp; mistake2, TreeNode*&amp; prev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, mistake1, mistake2, prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev &amp;&amp; root-&gt;val &lt; prev-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mistake1) &#123;</span><br><span class="line">            mistake1 = prev;</span><br><span class="line">            mistake2 = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mistake2 = root;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; mistake1-&gt;val;</span><br><span class="line">        cout &lt;&lt; mistake2-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, mistake1, mistake2, prev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="669-Trim-a-Binary-Search-Tree-Easy"><a href="#669-Trim-a-Binary-Search-Tree-Easy" class="headerlink" title="669. Trim a Binary Search Tree (Easy)"></a>669. Trim a Binary Search Tree (Easy)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个二叉查找树和两个整数L和R，且L&lt;R，试修剪此二叉查找树，使得修剪后所有节点的值都在[L,R]的范围内。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二叉查找树和两个整数L和R，输出一个被修剪好的二叉查找树。</p></li><li><p><strong>题解</strong></p><p>利用二叉查找树的大小关系，我们可以很容易地利用递归进行树的处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; L) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, L, R);</span><br><span class="line">    root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, L, R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>字典树（Trie）用于判断字符串是否存在或者是否具有某种字符串前缀。</p><p>为什么需要用字典树解决这类问题呢？假如我们有一个储存了近万个单词的字典，即使我们使用哈希，在其中搜索一个单词的实际开销也是非常大的，且无法轻易支持搜索单词前缀。然而由于一个英文单词的长度n通常在 10 以内，如果我们使用字典树，则可以在O(n)——近似 O(1)的时间内完成搜索，且额外开销非常小。</p><h4 id="208-Implement-Trie-Prefix-Tree-Medium"><a href="#208-Implement-Trie-Prefix-Tree-Medium" class="headerlink" title="208. Implement Trie (Prefix Tree) (Medium)"></a>208. Implement Trie (Prefix Tree) (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>尝试建立一个字典树，支持快速插入单词、查找单词、查找单词前缀的功能。</p></li><li><p><strong>输入输出样例</strong></p><p>以下是数据结构的调用样例。</p><blockquote><p>Trie trie &#x3D;newTrie();<br>trie.insert(“apple”);<br>trie.search(“apple”); &#x2F;&#x2F; true<br>trie.search(“app”); &#x2F;&#x2F; false<br>trie.startsWith(“app”); &#x2F;&#x2F;true<br>trie.insert(“app”);<br>trie.search(“app”); &#x2F;&#x2F; true</p></blockquote></li><li><p><strong>题解</strong></p><p>以下是字典树的典型实现方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* childNode[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> isVal;</span><br><span class="line">    <span class="built_in">TrieNode</span>(): <span class="built_in">isVal</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            childNode[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    TrieNode* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>(): <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向字典树插入一个词</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* temp = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!temp-&gt;childNode[word[i]-’a’]) &#123;</span><br><span class="line">                temp-&gt;childNode[word[i]-’a’] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;childNode[word[i]-’a’];</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;isVal = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断字典树里是否有一个词</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* temp = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!temp) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;childNode[word[i]-’a’];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp? temp-&gt;isVal: <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断字典树是否有一个以词开始的前缀</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* temp = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prefix.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!temp) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;childNode[prefix[i]-’a’];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-12"><a href="#练习-12" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree (Easy)</a></p><p><a href="https://leetcode.com/problems/merge-two-binary-trees/">617. Merge Two Binary Trees (Easy)</a></p><p><a href="https://leetcode.com/problems/subtree-of-another-tree/">572. Subtree of Another Tree (Easy)</a></p><p><a href="https://leetcode.com/problems/sum-of-left-leaves/">404. Sum of Left Leaves (Easy)</a></p><p><a href="https://leetcode.com/problems/find-bottom-left-tree-value/">513. Find Bottom Left Tree Value (Easy)</a></p><p><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree (Easy)</a></p><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree (Easy)</a></p><p><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">530. Minimum Absolute Difference in BST (Easy)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)</a></p><p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</a></p><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal (Medium)</a></p><p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/">145. Binary Tree Postorder Traversal (Medium)</a></p><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree (Medium)</a></p><p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">109. Convert Sorted List to Binary Search Tree (Medium)</a></p><p><a href="https://leetcode.com/problems/increasing-order-search-tree/">897. Increasing Order Search Tree (Easy)</a></p><p><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/">653. Two Sum IV - Input is a BST (Easy)</a></p><p><a href="https://leetcode.com/problems/delete-node-in-a-bst/">450. Delete Node in a BST (Medium)</a></p></li></ul><h2 id="第-15-章-指针三剑客之三：图"><a href="#第-15-章-指针三剑客之三：图" class="headerlink" title="第 15 章 指针三剑客之三：图"></a>第 15 章 指针三剑客之三：图</h2><h3 id="数据结构介绍-2"><a href="#数据结构介绍-2" class="headerlink" title="数据结构介绍"></a>数据结构介绍</h3><p>作为指针三剑客之三，图是树的升级版。图通常分为有向（directed）或无向（undirected），有循环（cyclic）或无循环（acyclic），所有节点相连（connected）或不相连（disconnected）。树即是一个相连的无向无环图，而另一种很常见的图是有向无环图（Directed Acyclic Graph，DAG）。</p><p>图通常有两种表示方法。假设图中一共有 n 个节点、m 条边。第一种表示方法是邻接矩阵（adjacency matrix）：我们可以建立一个 n × n 的矩阵 G，如果第 i 个节点连向第 j 个节点，则 G[i][j]&#x3D; 1，反之为 0；如果图是无向的，则这个矩阵一定是对称矩阵，即 G[i][j] &#x3D; G[j][i]。第二种表示方法是邻接链表（adjacency list）：我们可以建立一个大小为 n 的数组，每个位置 i 储存一个数组或者链表，表示第 i 个节点连向的其它节点。邻接矩阵空间开销比邻接链表大，但是邻接链表不支持快速查找 i 和 j 是否相连，因此两种表示方法可以根据题目需要适当选择。除此之外，我们也可以直接用一个 m × 2 的矩阵储存所有的边。</p><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>二分图算法也称为染色法，是一种广度优先搜索。如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么图为二分。</p><h4 id="785-Is-Graph-Bipartite-Medium"><a href="#785-Is-Graph-Bipartite-Medium" class="headerlink" title="785. Is Graph Bipartite? (Medium)"></a>785. Is Graph Bipartite? (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定一个图，判断其是否可以二分</p></li><li><p><strong>输入输出样例</strong></p><p>输入是邻接链表表示的图（如位置 0 的邻接链表为[1,3]，表示 0 与 1 、 0 与 3 相连）；输出是一个布尔值，表示图是否二分。</p></li><li><p><strong>题解</strong></p><p>利用队列和广度优先搜索，我们可以对未染色的节点进行染色，并且检查是否有颜色相同的相邻节点存在。注意在代码中，我们用 0 表示未检查的节点，用 1 和 2 表示两种不同的颜色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">color</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!color[i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            color[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; j: graph[node]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (color[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    color[j] = color[node] == <span class="number">2</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[node] == color[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>拓扑排序（topological sort）是一种常见的，对有向无环图排序的算法。给定有向无环图中的N个节点，我们把它们排序成一个线性序列；若原图中节点i指向节点j，则排序结果中i一定在j之前。拓扑排序的结果不是唯一的，只要满足以上条件即可。</p><h4 id="210-Course-Schedule-II-Medium"><a href="#210-Course-Schedule-II-Medium" class="headerlink" title="210. Course Schedule II (Medium)"></a>210. Course Schedule II (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>给定N个课程和这些课程的前置必修课，求可以一次性上完所有课的顺序。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个正整数，表示课程数量，和一个二维矩阵，表示所有的有向边（如[1,0]表示上课程 1 之前必须先上课程 0 ）。输出是一个一维数组，表示拓扑排序结果。</p><blockquote><p>Input: numCourses &#x3D; 4, prerequisites &#x3D; [[1,0],[2,0],[3,1],[3,2]]<br>Output: [0,1,2,3]</p></blockquote><p>在这个样例中，另一种可行的顺序是[0,2,1,3]。</p></li><li><p><strong>题解</strong></p><p>我们可以先建立一个邻接矩阵表示图，方便进行直接查找。这里注意我们将所有的边反向，使得如果课程i指向课程j，那么课程i需要在课程j前面先修完。这样更符合我们的直观理解。</p><p>拓扑排序也可以被看成是广度优先搜索的一种情况：我们先遍历一遍所有节点，把入度为0的节点（即没有前置课程要求）放在队列中。在每次从队列中获得节点时，我们将该节点放在目前排序的末尾，并且把它指向的课程的入度各减1；如果在这个过程中有课程的所有前置必修课都已修完（即入度为0），我们把这个节点加入队列中。当队列的节点都被处理完时，说明所有的节点都已排好序，或因图中存在循环而无法上完所有课程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(numCourses, <span class="number">0</span>)</span>, res</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; prerequisite: prerequisites) &#123;</span><br><span class="line">        graph[prerequisite[<span class="number">1</span>]].<span class="built_in">push_back</span>(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        ++indegree[prerequisite[<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; indegree.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!indegree[i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(u);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v: graph[u]) &#123;</span><br><span class="line">            --indegree[v];</span><br><span class="line">            <span class="keyword">if</span> (!indegree[v]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; indegree.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-13"><a href="#练习-13" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/all-paths-from-source-lead-to-destination/">1059. All Paths from Source Lead to Destination (Medium)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/connecting-cities-with-minimum-cost/">1135. Connecting Cities With Minimum Cost (Medium)</a></p><p><a href="https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/">882. Reachable Nodes In Subdivided Graph (Hard)</a></p></li></ul><h2 id="第-16-章-更加复杂的数据结构"><a href="#第-16-章-更加复杂的数据结构" class="headerlink" title="第 16 章 更加复杂的数据结构"></a>第 16 章 更加复杂的数据结构</h2><h3 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h3><p>目前为止，我们接触了大量的数据结构，包括利用指针实现的三剑客和C++自带的STL等。对于一些题目，我们不仅需要利用多个数据结果解决问题，还需要把这些数据结构进行嵌套和联动，进行更为复杂、更为快速的操作。</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集（union-find,或disjoint set）可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。假设存在n个节点，我们先将所有节点的父亲标为自己；每次要连接节点i和j时，我们可以将i的父亲标为j；每次要查询两个节点是否相连时，我们可以查找i和j的祖先是否最终为同一个人。</p><h4 id="684-Redundant-Connection-Medium"><a href="#684-Redundant-Connection-Medium" class="headerlink" title="684. Redundant Connection (Medium)"></a>684. Redundant Connection (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>在无向图找出一条边，移除它之后该图能够成为一棵树（即无向无环图）。如果有多个解，返回在原数组中位置最靠后的那条边。</p></li><li><p><strong>输入输出样例</strong></p><p>输入是一个二维数组，表示所有的边（对应的两个节点）；输出是一个一维数组，表示需要移除的边（对应的两个节点）。</p></li><li><p><strong>题解</strong></p><p>因为需要判断是否两个节点被重复连通，所以我们可以使用并查集来解决此类问题。具体实现算法如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UF</span>(<span class="type">int</span> n): <span class="built_in">id</span>(n)&#123;</span><br><span class="line">        <span class="built_in">iota</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// iota函数可以把数组初始化为0到n-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p != id[p]) &#123;</span><br><span class="line">            p = id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        id[<span class="built_in">find</span>(p)] = <span class="built_in">find</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UF <span class="title">uf</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: edges) &#123;</span><br><span class="line">            <span class="type">int</span> u = e[<span class="number">0</span>], v = e[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (uf.<span class="built_in">isConnected</span>(u, v)) &#123;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            uf.<span class="built_in">connect</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了加速查找，我们可以使用路径压缩和按秩合并来优化并查集。其具体写法如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; id, size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UF</span>(<span class="type">int</span> n): <span class="built_in">id</span>(n), <span class="built_in">size</span>(n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">iota</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// iota函数可以把数组初始化为0到n-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p != id[p]) &#123;</span><br><span class="line">            id[p] = id[id[p]]; <span class="comment">// 路径压缩，使得下次查找更快</span></span><br><span class="line">            p = id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">find</span>(p), j = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">            <span class="comment">// 按秩合并：每次合并都把深度较小的集合合并在深度较大的集合下面</span></span><br><span class="line">            <span class="keyword">if</span> (size[i] &lt; size[j]) &#123;</span><br><span class="line">                id[i] = j;</span><br><span class="line">                size[j] += size[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                id[j] = i;</span><br><span class="line">                size[i] += size[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="复合数据结构"><a href="#复合数据结构" class="headerlink" title="复合数据结构"></a>复合数据结构</h3><p>这一类题通常采用unordered_map或map辅助记录，从而加速寻址；再配上vector或者list进行数据储存，从而加速连续选址或删除值。</p><h4 id="146-LRU-Cache-Medium"><a href="#146-LRU-Cache-Medium" class="headerlink" title="146. LRU Cache (Medium)"></a>146. LRU Cache (Medium)</h4><ul><li><p><strong>题目描述</strong></p><p>设计一个固定大小的，最少最近使用缓存(least recently used cache, LRU)。每次将信息插入未满的缓存的时候，以及更新或查找一个缓存内存在的信息的时候，将该信息标为最近使用。在缓存满的情况下将一个新信息插入的时候，需要移除最旧的信息，插入新信息，并将该信息标为最近使用。</p></li><li><p><strong>输入输出样例</strong></p><p>以下是数据结构的调用样例。给定一个大小为n的缓存，我们希望其使用最少最近使用策略进行数据储存。</p><blockquote><p>LRUCache cache &#x3D;newLRUCache( 2&#x2F;* capacity*&#x2F;);<br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1); &#x2F;&#x2F; returns 1<br>cache.put(3, 3); &#x2F;&#x2F; evicts key 2<br>cache.get(2); &#x2F;&#x2F; returns-1 (notfound)<br>cache.put(4, 4); &#x2F;&#x2F; evicts key 1<br>cache.get(1); &#x2F;&#x2F; returns-1 (notfound)<br>cache.get(3); &#x2F;&#x2F; returns 3<br>cache.get(4); &#x2F;&#x2F; returns 4</p></blockquote></li><li><p><strong>题解</strong></p><p>我们采用一个链表list&lt;pair&lt;int, int&gt;&gt;来储存信息的key和value，链表的链接顺序即为最近使用的新旧顺序，最新的信息在链表头节点。同时我们需要一个嵌套着链表的迭代器的un-ordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt;进行快速搜索，存迭代器的原因是方便调用链表的splice函数来直接更新查找成功（cash hit）时的信息，即把迭代器对应的节点移动为链表的头节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt; hash;</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; cache;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity):<span class="built_in">size</span>(capacity) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = hash.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.<span class="built_in">splice</span>(cache.<span class="built_in">begin</span>(), cache, it-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = hash.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            it-&gt;second-&gt;second = value;</span><br><span class="line">            <span class="keyword">return</span> cache.<span class="built_in">splice</span>(cache.<span class="built_in">begin</span>(), cache, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        cache.<span class="built_in">insert</span>(cache.<span class="built_in">begin</span>(), <span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        hash[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span> (cache.<span class="built_in">size</span>() &gt; size) &#123;</span><br><span class="line">            hash.<span class="built_in">erase</span>(cache.<span class="built_in">back</span>().first);</span><br><span class="line">            cache.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习-14"><a href="#练习-14" class="headerlink" title="练习"></a>练习</h3><ul><li><p><strong>基础难度</strong></p><p><a href="https://leetcode.com/problems/connecting-cities-with-minimum-cost/">1135. Connecting Cities With Minimum Cost (Medium)</a></p><p><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/">380. Insert Delete GetRandom O(1) (Medium)</a></p></li><li><p><strong>进阶难度</strong></p><p><a href="https://leetcode.com/problems/all-oone-data-structure/">432. All O‘one Data Structure (Hard)</a></p><p><a href="https://leetcode.com/problems/max-stack/">716. Max Stack (Easy)</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署GitHub搭建个人博客全过程</title>
      <link href="/2023/08/24/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/08/24/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>笔者有过几次搭建博客的经验，但大都心血来潮折腾一番而后不了了之。前段时间发现markdown文件写了一部分，但仍然有许多笔记和经验未尝规范记录，因此决心将所习有可取之经验或资源，加以整合后记录下来，以供自己未来查阅。言尽于此，就以博客的搭建作为第一篇的内容罢！</p><p>2023年8月24日：暂Windows环境</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><ul><li>账号准备：略</li><li>创建仓库：仓库名格式须为&lt;用户名&gt;.github.io，其他默认就好</li><li>预复制一个仓库的HTTPS地址</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul><li><p>下载地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p></li><li><p>安装：略</p></li><li><p>配置用户名和邮箱地址（用户名和邮箱与GitHub保持一致）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>配置SSH</p><p>创建ssh key–&gt;不要设置密码–&gt;查看生成的key并复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;email@example.com&quot;</span></span><br><span class="line">&lt;Enter&gt;&lt;Enter&gt;</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><blockquote><p>去GitHub–&gt;Account Settings–&gt;找到sshkey添加即可</p></blockquote><p>验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><ul><li>下载地址：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a></li><li>安装：略，有强迫症者安装位置不选择系统盘，可在安装好自行添加环境变量</li></ul><h2 id="着手搭建"><a href="#着手搭建" class="headerlink" title="着手搭建"></a>着手搭建</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ul><li><p>合适位置新建文件夹命名hexo</p></li><li><p>git bash here</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>hexo命令</p><p>generate 生成静态网页</p><p>server 本地部署</p><p>deploy 部署到仓库</p><p>clean 清除生成的静态文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li></ul><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><ul><li><p>笔者使用butterfly：<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p></li><li><p>blog文件夹git bash here</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><blockquote><p>git克隆项目失败(https)报错：server certificate verification failed</p><p>解决办法：git config –global http.sslverify false</p></blockquote></li><li><p>修改blog文件夹下_config.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure></li><li><p>如果没有pug以及stylus的渲染器，下载安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure></li></ul><h3 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3><ul><li><p>安装部署命令工具，blog文件夹git bash here</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>修改根目录下的_config.yml，配置相关信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://仓库名</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">预复制的仓库HTTPS地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li><p>部署到GitHub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><blockquote><p>hexo d失败：极有可能是挂梯子的问题，搜索回答说代理会使电脑网络环境出现一些默认设置</p><p>解决办法：把github添加到windows的host文件中；文件路径:C:\Windows\System32\drivers\etc，在host文件最下边添加192.30.255.113 github.com</p></blockquote></li></ul><p>搭建完成后仍需更多对主题、插件、markdown相关插入资源的设置，笔者建议可以随着博文对功能的需要而逐步添加、美化，若只是一味地按照主题官方文档粉饰而没有博文质与量的上升，那便是本末倒置了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/08/16/hello-world/"/>
      <url>/2023/08/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>. <a href="#Deploy-to-remote-sites">Deploy to remote sites</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> test 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test tags </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
